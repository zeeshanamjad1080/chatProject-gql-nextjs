"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-resizable-panels";
exports.ids = ["vendor-chunks/react-resizable-panels"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   PanelGroup: () => (/* binding */ PanelGroup),\n/* harmony export */   PanelResizeHandle: () => (/* binding */ PanelResizeHandle),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   getPanelElement: () => (/* binding */ getPanelElement),\n/* harmony export */   getPanelElementsForGroup: () => (/* binding */ getPanelElementsForGroup),\n/* harmony export */   getPanelGroupElement: () => (/* binding */ getPanelGroupElement),\n/* harmony export */   getResizeHandleElement: () => (/* binding */ getResizeHandleElement),\n/* harmony export */   getResizeHandleElementIndex: () => (/* binding */ getResizeHandleElementIndex),\n/* harmony export */   getResizeHandleElementsForGroup: () => (/* binding */ getResizeHandleElementsForGroup),\n/* harmony export */   getResizeHandlePanelIds: () => (/* binding */ getResizeHandlePanelIds)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n// eslint-disable-next-line no-restricted-imports\nconst { createElement, createContext, createRef, forwardRef, useCallback, useContext, useEffect, useImperativeHandle, useLayoutEffect, useMemo, useRef, useState } = react__WEBPACK_IMPORTED_MODULE_0__;\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = react__WEBPACK_IMPORTED_MODULE_0__[\"useId\".toString()];\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\nconst wrappedUseId = typeof useId === \"function\" ? useId : ()=>null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n    const idFromUseId = wrappedUseId();\n    const idRef = useRef(idFromParams || idFromUseId || null);\n    if (idRef.current === null) {\n        idRef.current = \"\" + counter++;\n    }\n    return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\nfunction PanelWithForwardedRef({ children, className: classNameFromProps = \"\", collapsedSize, collapsible, defaultSize, forwardedRef, id: idFromProps, maxSize, minSize, onCollapse, onExpand, onResize, order, style: styleFromProps, tagName: Type = \"div\", ...rest }) {\n    const context = useContext(PanelGroupContext);\n    if (context === null) {\n        throw Error(`Panel components must be rendered within a PanelGroup container`);\n    }\n    const { collapsePanel, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, reevaluatePanelConstraints, registerPanel, resizePanel, unregisterPanel } = context;\n    const panelId = useUniqueId(idFromProps);\n    const panelDataRef = useRef({\n        callbacks: {\n            onCollapse,\n            onExpand,\n            onResize\n        },\n        constraints: {\n            collapsedSize,\n            collapsible,\n            defaultSize,\n            maxSize,\n            minSize\n        },\n        id: panelId,\n        idIsFromProps: idFromProps !== undefined,\n        order\n    });\n    const devWarningsRef = useRef({\n        didLogMissingDefaultSizeWarning: false\n    });\n    // Normally we wouldn't log a warning during render,\n    // but effects don't run on the server, so we can't do it there\n    {\n        if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) {\n            if (defaultSize == null) {\n                devWarningsRef.current.didLogMissingDefaultSizeWarning = true;\n                console.warn(`WARNING: Panel defaultSize prop recommended to avoid layout shift after server rendering`);\n            }\n        }\n    }\n    useImperativeHandle(forwardedRef, ()=>({\n            collapse: ()=>{\n                collapsePanel(panelDataRef.current);\n            },\n            expand: ()=>{\n                expandPanel(panelDataRef.current);\n            },\n            getId () {\n                return panelId;\n            },\n            getSize () {\n                return getPanelSize(panelDataRef.current);\n            },\n            isCollapsed () {\n                return isPanelCollapsed(panelDataRef.current);\n            },\n            isExpanded () {\n                return !isPanelCollapsed(panelDataRef.current);\n            },\n            resize: (size)=>{\n                resizePanel(panelDataRef.current, size);\n            }\n        }), [\n        collapsePanel,\n        expandPanel,\n        getPanelSize,\n        isPanelCollapsed,\n        panelId,\n        resizePanel\n    ]);\n    const style = getPanelStyle(panelDataRef.current, defaultSize);\n    return createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        // CSS selectors\n        \"data-panel\": \"\",\n        \"data-panel-id\": panelId,\n        \"data-panel-group-id\": groupId,\n        // e2e test attributes\n        \"data-panel-collapsible\": collapsible || undefined,\n        \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1)\n    });\n}\nconst Panel = forwardRef((props, ref)=>createElement(PanelWithForwardedRef, {\n        ...props,\n        forwardedRef: ref\n    }));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\nfunction assert(expectedCondition, message = \"Assertion failed!\") {\n    if (!expectedCondition) {\n        console.error(message);\n        throw Error(message);\n    }\n}\nconst PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n    actual = parseFloat(actual.toFixed(fractionDigits));\n    expected = parseFloat(expected.toFixed(fractionDigits));\n    const delta = actual - expected;\n    if (delta === 0) {\n        return 0;\n    } else {\n        return delta > 0 ? 1 : -1;\n    }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n    return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({ panelConstraints: panelConstraintsArray, panelIndex, size }) {\n    const panelConstraints = panelConstraintsArray[panelIndex];\n    assert(panelConstraints != null);\n    let { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panelConstraints;\n    if (fuzzyCompareNumbers(size, minSize) < 0) {\n        if (collapsible) {\n            // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n            const halfwayPoint = (collapsedSize + minSize) / 2;\n            if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n                size = collapsedSize;\n            } else {\n                size = minSize;\n            }\n        } else {\n            size = minSize;\n        }\n    }\n    size = Math.min(maxSize, size);\n    size = parseFloat(size.toFixed(PRECISION));\n    return size;\n}\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({ delta, layout: prevLayout, panelConstraints: panelConstraintsArray, pivotIndices, trigger }) {\n    if (fuzzyNumbersEqual(delta, 0)) {\n        return prevLayout;\n    }\n    const nextLayout = [\n        ...prevLayout\n    ];\n    const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n    assert(firstPivotIndex != null);\n    assert(secondPivotIndex != null);\n    let deltaApplied = 0;\n    //const DEBUG = [];\n    //DEBUG.push(`adjustLayoutByDelta() ${prevLayout.join(\", \")}`);\n    //DEBUG.push(`  delta: ${delta}`);\n    //DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n    //DEBUG.push(`  trigger: ${trigger}`);\n    //DEBUG.push(\"\");\n    // A resizing panel affects the panels before or after it.\n    //\n    // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n    // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n    //\n    // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n    // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n    {\n        // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n        // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n        if (trigger === \"keyboard\") {\n            {\n                // Check if we should expand a collapsed panel\n                const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n                const panelConstraints = panelConstraintsArray[index];\n                assert(panelConstraints);\n                //DEBUG.push(`edge case check 1: ${index}`);\n                //DEBUG.push(`  -> collapsible? ${constraints.collapsible}`);\n                if (panelConstraints.collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const panelConstraints = panelConstraintsArray[index];\n                    assert(panelConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = panelConstraints;\n                    if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n                        const localDelta = minSize - prevSize;\n                        //DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        //DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n            {\n                // Check if we should collapse a panel at its minimum size\n                const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n                const panelConstraints = panelConstraintsArray[index];\n                assert(panelConstraints);\n                const { collapsible } = panelConstraints;\n                //DEBUG.push(`edge case check 2: ${index}`);\n                //DEBUG.push(`  -> collapsible? ${collapsible}`);\n                if (collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const panelConstraints = panelConstraintsArray[index];\n                    assert(panelConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = panelConstraints;\n                    if (fuzzyNumbersEqual(prevSize, minSize)) {\n                        const localDelta = prevSize - collapsedSize;\n                        //DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        //DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n        }\n    //DEBUG.push(\"\");\n    }\n    {\n        // Pre-calculate max available delta in the opposite direction of our pivot.\n        // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n        // If this amount is less than the requested delta, adjust the requested delta.\n        // If this amount is greater than the requested delta, that's useful information too–\n        // as an expanding panel might change from collapsed to min size.\n        const increment = delta < 0 ? 1 : -1;\n        let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        let maxAvailableDelta = 0;\n        //DEBUG.push(\"pre calc...\");\n        while(true){\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const maxSafeSize = resizePanel({\n                panelConstraints: panelConstraintsArray,\n                panelIndex: index,\n                size: 100\n            });\n            const delta = maxSafeSize - prevSize;\n            //DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n            maxAvailableDelta += delta;\n            index += increment;\n            if (index < 0 || index >= panelConstraintsArray.length) {\n                break;\n            }\n        }\n        //DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n        const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n        delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    //DEBUG.push(`  -> adjusted delta: ${delta}`);\n    //DEBUG.push(\"\");\n    }\n    {\n        // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n        const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        let index = pivotIndex;\n        while(index >= 0 && index < panelConstraintsArray.length){\n            const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize - deltaRemaining;\n            const safeSize = resizePanel({\n                panelConstraints: panelConstraintsArray,\n                panelIndex: index,\n                size: unsafeSize\n            });\n            if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n                deltaApplied += prevSize - safeSize;\n                nextLayout[index] = safeSize;\n                if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n                    numeric: true\n                }) >= 0) {\n                    break;\n                }\n            }\n            if (delta < 0) {\n                index--;\n            } else {\n                index++;\n            }\n        }\n    }\n    //DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n    //DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n    //DEBUG.push(\"\");\n    // If we were unable to resize any of the panels panels, return the previous state.\n    // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n    if (fuzzyNumbersEqual(deltaApplied, 0)) {\n        //console.log(DEBUG.join(\"\\n\"));\n        return prevLayout;\n    }\n    {\n        // Now distribute the applied delta to the panels in the other direction\n        const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const prevSize = prevLayout[pivotIndex];\n        assert(prevSize != null);\n        const unsafeSize = prevSize + deltaApplied;\n        const safeSize = resizePanel({\n            panelConstraints: panelConstraintsArray,\n            panelIndex: pivotIndex,\n            size: unsafeSize\n        });\n        // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n        nextLayout[pivotIndex] = safeSize;\n        // Edge case where expanding or contracting one panel caused another one to change collapsed state\n        if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n            let deltaRemaining = unsafeSize - safeSize;\n            const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n            let index = pivotIndex;\n            while(index >= 0 && index < panelConstraintsArray.length){\n                const prevSize = nextLayout[index];\n                assert(prevSize != null);\n                const unsafeSize = prevSize + deltaRemaining;\n                const safeSize = resizePanel({\n                    panelConstraints: panelConstraintsArray,\n                    panelIndex: index,\n                    size: unsafeSize\n                });\n                if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n                    deltaRemaining -= safeSize - prevSize;\n                    nextLayout[index] = safeSize;\n                }\n                if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n                    break;\n                }\n                if (delta > 0) {\n                    index--;\n                } else {\n                    index++;\n                }\n            }\n        }\n    }\n    //DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n    //DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n    //DEBUG.push(\"\");\n    const totalSize = nextLayout.reduce((total, size)=>size + total, 0);\n    //DEBUG.push(`total size: ${totalSize}`);\n    //console.log(DEBUG.join(\"\\n\"));\n    if (!fuzzyNumbersEqual(totalSize, 100)) {\n        return prevLayout;\n    }\n    return nextLayout;\n}\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n    return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n    const handles = getResizeHandleElementsForGroup(groupId, scope);\n    const index = handles.findIndex((handle)=>handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n    return index !== null && index !== void 0 ? index : null;\n}\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n    const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n    return index != null ? [\n        index,\n        index + 1\n    ] : [\n        -1,\n        -1\n    ];\n}\nfunction getPanelGroupElement(id, rootElement = document) {\n    var _dataset;\n    //If the root element is the PanelGroup\n    if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id) {\n        return rootElement;\n    }\n    //Else query children\n    const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getResizeHandleElement(id, scope = document) {\n    const element = scope.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n    var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n    const handle = getResizeHandleElement(handleId, scope);\n    const handles = getResizeHandleElementsForGroup(groupId, scope);\n    const index = handle ? handles.indexOf(handle) : -1;\n    const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n    const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n    return [\n        idBefore,\n        idAfter\n    ];\n}\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\nfunction useWindowSplitterPanelGroupBehavior({ committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, panelGroupElement, setLayout }) {\n    useRef({\n        didWarnAboutMissingResizeHandle: false\n    });\n    useEffect(()=>{\n        if (!panelGroupElement) {\n            return;\n        }\n        const eagerValues = eagerValuesRef.current;\n        assert(eagerValues);\n        const { panelDataArray } = eagerValues;\n        const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n        assert(groupElement != null, `No group found for id \"${groupId}\"`);\n        const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n        assert(handles);\n        const cleanupFunctions = handles.map((handle)=>{\n            const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n            assert(handleId);\n            const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n            if (idBefore == null || idAfter == null) {\n                return ()=>{};\n            }\n            const onKeyDown = (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                switch(event.key){\n                    case \"Enter\":\n                        {\n                            event.preventDefault();\n                            const index = panelDataArray.findIndex((panelData)=>panelData.id === idBefore);\n                            if (index >= 0) {\n                                const panelData = panelDataArray[index];\n                                assert(panelData);\n                                const size = layout[index];\n                                const { collapsedSize = 0, collapsible, minSize = 0 } = panelData.constraints;\n                                if (size != null && collapsible) {\n                                    const nextLayout = adjustLayoutByDelta({\n                                        delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                                        layout,\n                                        panelConstraints: panelDataArray.map((panelData)=>panelData.constraints),\n                                        pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                                        trigger: \"keyboard\"\n                                    });\n                                    if (layout !== nextLayout) {\n                                        setLayout(nextLayout);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                }\n            };\n            handle.addEventListener(\"keydown\", onKeyDown);\n            return ()=>{\n                handle.removeEventListener(\"keydown\", onKeyDown);\n            };\n        });\n        return ()=>{\n            cleanupFunctions.forEach((cleanupFunction)=>cleanupFunction());\n        };\n    }, [\n        panelGroupElement,\n        committedValuesRef,\n        eagerValuesRef,\n        groupId,\n        layout,\n        panelDataArray,\n        setLayout\n    ]);\n}\nfunction areEqual(arrayA, arrayB) {\n    if (arrayA.length !== arrayB.length) {\n        return false;\n    }\n    for(let index = 0; index < arrayA.length; index++){\n        if (arrayA[index] !== arrayB[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isKeyDown(event) {\n    return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n    return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n    return event.type.startsWith(\"touch\");\n}\nfunction getResizeEventCursorPosition(direction, event) {\n    const isHorizontal = direction === \"horizontal\";\n    if (isMouseEvent(event)) {\n        return isHorizontal ? event.clientX : event.clientY;\n    } else if (isTouchEvent(event)) {\n        const firstTouch = event.touches[0];\n        assert(firstTouch);\n        return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n    } else {\n        throw Error(`Unsupported event type \"${event.type}\"`);\n    }\n}\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n    const isHorizontal = direction === \"horizontal\";\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n    assert(handleElement);\n    const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n    assert(groupId);\n    let { initialCursorPosition } = initialDragState;\n    const cursorPosition = getResizeEventCursorPosition(direction, event);\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement);\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n    return offsetPercentage;\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n    if (isKeyDown(event)) {\n        const isHorizontal = direction === \"horizontal\";\n        let delta = 0;\n        if (event.shiftKey) {\n            delta = 100;\n        } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n        } else {\n            delta = 10;\n        }\n        let movement = 0;\n        switch(event.key){\n            case \"ArrowDown\":\n                movement = isHorizontal ? 0 : delta;\n                break;\n            case \"ArrowLeft\":\n                movement = isHorizontal ? -delta : 0;\n                break;\n            case \"ArrowRight\":\n                movement = isHorizontal ? delta : 0;\n                break;\n            case \"ArrowUp\":\n                movement = isHorizontal ? 0 : -delta;\n                break;\n            case \"End\":\n                movement = 100;\n                break;\n            case \"Home\":\n                movement = -100;\n                break;\n        }\n        return movement;\n    } else {\n        if (initialDragState == null) {\n            return 0;\n        }\n        return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n    }\n}\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n    layout.forEach((size, index)=>{\n        const panelData = panelsArray[index];\n        assert(panelData);\n        const { callbacks, constraints, id: panelId } = panelData;\n        const { collapsedSize = 0, collapsible } = constraints;\n        const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n        if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n            panelIdToLastNotifiedSizeMap[panelId] = size;\n            const { onCollapse, onExpand, onResize } = callbacks;\n            if (onResize) {\n                onResize(size, lastNotifiedSize);\n            }\n            if (collapsible && (onCollapse || onExpand)) {\n                if (onExpand && (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {\n                    onExpand();\n                }\n                if (onCollapse && (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) && size === collapsedSize) {\n                    onCollapse();\n                }\n            }\n        }\n    });\n}\nfunction compareLayouts(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    } else {\n        for(let index = 0; index < a.length; index++){\n            if (a[index] != b[index]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({ defaultSize, dragState, layout, panelData, panelIndex, precision = 3 }) {\n    const size = layout[panelIndex];\n    let flexGrow;\n    if (size == null) {\n        // Initial render (before panels have registered themselves)\n        // In order to support server rendering, fall back to default size if provided\n        flexGrow = defaultSize !== null && defaultSize !== void 0 ? defaultSize : \"1\";\n    } else if (panelData.length === 1) {\n        // Special case: Single panel group should always fill full width/height\n        flexGrow = \"1\";\n    } else {\n        flexGrow = size.toPrecision(precision);\n    }\n    return {\n        flexBasis: 0,\n        flexGrow,\n        flexShrink: 1,\n        // Without this, Panel sizes may be unintentionally overridden by their content\n        overflow: \"hidden\",\n        // Disable pointer events inside of a panel during resize\n        // This avoid edge cases like nested iframes\n        pointerEvents: dragState !== null ? \"none\" : undefined\n    };\n}\nlet currentState = null;\nlet element = null;\nfunction getCursorStyle(state) {\n    switch(state){\n        case \"horizontal\":\n            return \"ew-resize\";\n        case \"horizontal-max\":\n            return \"w-resize\";\n        case \"horizontal-min\":\n            return \"e-resize\";\n        case \"vertical\":\n            return \"ns-resize\";\n        case \"vertical-max\":\n            return \"n-resize\";\n        case \"vertical-min\":\n            return \"s-resize\";\n    }\n}\nfunction resetGlobalCursorStyle() {\n    if (element !== null) {\n        document.head.removeChild(element);\n        currentState = null;\n        element = null;\n    }\n}\nfunction setGlobalCursorStyle(state) {\n    if (currentState === state) {\n        return;\n    }\n    currentState = state;\n    const style = getCursorStyle(state);\n    if (element === null) {\n        element = document.createElement(\"style\");\n        document.head.appendChild(element);\n    }\n    element.innerHTML = `*{cursor: ${style}!important;}`;\n}\nfunction debounce(callback, durationMs = 10) {\n    let timeoutId = null;\n    let callable = (...args)=>{\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(()=>{\n            callback(...args);\n        }, durationMs);\n    };\n    return callable;\n}\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n    try {\n        if (typeof localStorage !== \"undefined\") {\n            // Bypass this check for future calls\n            storageObject.getItem = (name)=>{\n                return localStorage.getItem(name);\n            };\n            storageObject.setItem = (name, value)=>{\n                localStorage.setItem(name, value);\n            };\n        } else {\n            throw new Error(\"localStorage not supported in this environment\");\n        }\n    } catch (error) {\n        console.error(error);\n        storageObject.getItem = ()=>null;\n        storageObject.setItem = ()=>{};\n    }\n}\nfunction getPanelGroupKey(autoSaveId) {\n    return `react-resizable-panels:${autoSaveId}`;\n}\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n    return panels.map((panel)=>{\n        const { constraints, id, idIsFromProps, order } = panel;\n        if (idIsFromProps) {\n            return id;\n        } else {\n            return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n        }\n    }).sort((a, b)=>a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n    try {\n        const panelGroupKey = getPanelGroupKey(autoSaveId);\n        const serialized = storage.getItem(panelGroupKey);\n        if (serialized) {\n            const parsed = JSON.parse(serialized);\n            if (typeof parsed === \"object\" && parsed != null) {\n                return parsed;\n            }\n        }\n    } catch (error) {}\n    return null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n    var _loadSerializedPanelG2;\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const panelKey = getPanelKey(panels);\n    const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n    state[panelKey] = {\n        expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n        layout: sizes\n    };\n    try {\n        storage.setItem(panelGroupKey, JSON.stringify(state));\n    } catch (error) {\n        console.error(error);\n    }\n}\nfunction validatePanelConstraints({ panelConstraints: panelConstraintsArray, panelId, panelIndex }) {\n    {\n        const warnings = [];\n        const panelConstraints = panelConstraintsArray[panelIndex];\n        assert(panelConstraints);\n        const { collapsedSize = 0, collapsible = false, defaultSize, maxSize = 100, minSize = 0 } = panelConstraints;\n        if (minSize > maxSize) {\n            warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);\n        }\n        if (defaultSize != null) {\n            if (defaultSize < 0) {\n                warnings.push(\"default size should not be less than 0\");\n            } else if (defaultSize < minSize && (!collapsible || defaultSize !== collapsedSize)) {\n                warnings.push(\"default size should not be less than min size\");\n            }\n            if (defaultSize > 100) {\n                warnings.push(\"default size should not be greater than 100\");\n            } else if (defaultSize > maxSize) {\n                warnings.push(\"default size should not be greater than max size\");\n            }\n        }\n        if (collapsedSize > minSize) {\n            warnings.push(\"collapsed size should not be greater than min size\");\n        }\n        if (warnings.length > 0) {\n            const name = panelId != null ? `Panel \"${panelId}\"` : \"Panel\";\n            console.warn(`${name} has an invalid configuration:\\n\\n${warnings.join(\"\\n\")}`);\n            return false;\n        }\n    }\n    return true;\n}\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({ layout: prevLayout, panelConstraints }) {\n    const nextLayout = [\n        ...prevLayout\n    ];\n    const nextLayoutTotalSize = nextLayout.reduce((accumulated, current)=>accumulated + current, 0);\n    // Validate layout expectations\n    if (nextLayout.length !== panelConstraints.length) {\n        throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size)=>`${size}%`).join(\", \")}`);\n    } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100)) {\n        // This is not ideal so we should warn about it, but it may be recoverable in some cases\n        // (especially if the amount is small)\n        {\n            console.warn(`WARNING: Invalid layout total size: ${nextLayout.map((size)=>`${size}%`).join(\", \")}. Layout normalization will be applied.`);\n        }\n        for(let index = 0; index < panelConstraints.length; index++){\n            const unsafeSize = nextLayout[index];\n            assert(unsafeSize != null);\n            const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    let remainingSize = 0;\n    // First pass: Validate the proposed layout given each panel's constraints\n    for(let index = 0; index < panelConstraints.length; index++){\n        const unsafeSize = nextLayout[index];\n        assert(unsafeSize != null);\n        const safeSize = resizePanel({\n            panelConstraints,\n            panelIndex: index,\n            size: unsafeSize\n        });\n        if (unsafeSize != safeSize) {\n            remainingSize += unsafeSize - safeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    // If there is additional, left over space, assign it to any panel(s) that permits it\n    // (It's not worth taking multiple additional passes to evenly distribute)\n    if (!fuzzyNumbersEqual(remainingSize, 0)) {\n        for(let index = 0; index < panelConstraints.length; index++){\n            const prevSize = nextLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize + remainingSize;\n            const safeSize = resizePanel({\n                panelConstraints,\n                panelIndex: index,\n                size: unsafeSize\n            });\n            if (prevSize !== safeSize) {\n                remainingSize -= safeSize - prevSize;\n                nextLayout[index] = safeSize;\n                // Once we've used up the remainder, bail\n                if (fuzzyNumbersEqual(remainingSize, 0)) {\n                    break;\n                }\n            }\n        }\n    }\n    return nextLayout;\n}\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n    getItem: (name)=>{\n        initializeDefaultStorage(defaultStorage);\n        return defaultStorage.getItem(name);\n    },\n    setItem: (name, value)=>{\n        initializeDefaultStorage(defaultStorage);\n        defaultStorage.setItem(name, value);\n    }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({ autoSaveId = null, children, className: classNameFromProps = \"\", direction, forwardedRef, id: idFromProps = null, onLayout = null, keyboardResizeBy = null, storage = defaultStorage, style: styleFromProps, tagName: Type = \"div\", ...rest }) {\n    const groupId = useUniqueId(idFromProps);\n    const panelGroupElementRef = useRef(null);\n    const [dragState, setDragState] = useState(null);\n    const [layout, setLayout] = useState([]);\n    const panelIdToLastNotifiedSizeMapRef = useRef({});\n    const panelSizeBeforeCollapseRef = useRef(new Map());\n    const prevDeltaRef = useRef(0);\n    const committedValuesRef = useRef({\n        autoSaveId,\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout,\n        storage\n    });\n    const eagerValuesRef = useRef({\n        layout,\n        panelDataArray: [],\n        panelDataArrayChanged: false\n    });\n    const devWarningsRef = useRef({\n        didLogIdAndOrderWarning: false,\n        didLogPanelConstraintsWarning: false,\n        prevPanelIds: []\n    });\n    useImperativeHandle(forwardedRef, ()=>({\n            getId: ()=>committedValuesRef.current.id,\n            getLayout: ()=>{\n                const { layout } = eagerValuesRef.current;\n                return layout;\n            },\n            setLayout: (unsafeLayout)=>{\n                const { onLayout } = committedValuesRef.current;\n                const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n                const safeLayout = validatePanelGroupLayout({\n                    layout: unsafeLayout,\n                    panelConstraints: panelDataArray.map((panelData)=>panelData.constraints)\n                });\n                if (!areEqual(prevLayout, safeLayout)) {\n                    setLayout(safeLayout);\n                    eagerValuesRef.current.layout = safeLayout;\n                    if (onLayout) {\n                        onLayout(safeLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }), []);\n    useWindowSplitterPanelGroupBehavior({\n        committedValuesRef,\n        eagerValuesRef,\n        groupId,\n        layout,\n        panelDataArray: eagerValuesRef.current.panelDataArray,\n        setLayout,\n        panelGroupElement: panelGroupElementRef.current\n    });\n    useEffect(()=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        // If this panel has been configured to persist sizing information, save sizes to local storage.\n        if (autoSaveId) {\n            if (layout.length === 0 || layout.length !== panelDataArray.length) {\n                return;\n            }\n            let debouncedSave = debounceMap[autoSaveId];\n            // Limit the frequency of localStorage updates.\n            if (debouncedSave == null) {\n                debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n                debounceMap[autoSaveId] = debouncedSave;\n            }\n            // Clone mutable data before passing to the debounced function,\n            // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n            const clonedPanelDataArray = [\n                ...panelDataArray\n            ];\n            const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n            debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n        }\n    }, [\n        autoSaveId,\n        layout,\n        storage\n    ]);\n    // DEV warnings\n    useEffect(()=>{\n        {\n            const { panelDataArray } = eagerValuesRef.current;\n            const { didLogIdAndOrderWarning, didLogPanelConstraintsWarning, prevPanelIds } = devWarningsRef.current;\n            if (!didLogIdAndOrderWarning) {\n                const panelIds = panelDataArray.map(({ id })=>id);\n                devWarningsRef.current.prevPanelIds = panelIds;\n                const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n                if (panelsHaveChanged) {\n                    if (panelDataArray.find(({ idIsFromProps, order })=>!idIsFromProps || order == null)) {\n                        devWarningsRef.current.didLogIdAndOrderWarning = true;\n                        console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n                    }\n                }\n            }\n            if (!didLogPanelConstraintsWarning) {\n                const panelConstraints = panelDataArray.map((panelData)=>panelData.constraints);\n                for(let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++){\n                    const panelData = panelDataArray[panelIndex];\n                    assert(panelData);\n                    const isValid = validatePanelConstraints({\n                        panelConstraints,\n                        panelId: panelData.id,\n                        panelIndex\n                    });\n                    if (!isValid) {\n                        devWarningsRef.current.didLogPanelConstraintsWarning = true;\n                        break;\n                    }\n                }\n            }\n        }\n    });\n    // External APIs are safe to memoize via committed values ref\n    const collapsePanel = useCallback((panelData)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        if (panelData.constraints.collapsible) {\n            const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n            const { collapsedSize = 0, panelSize, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n            assert(panelSize != null);\n            if (panelSize !== collapsedSize) {\n                // Store size before collapse;\n                // This is the size that gets restored if the expand() API is used.\n                panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n                const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n                const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n                const nextLayout = adjustLayoutByDelta({\n                    delta,\n                    layout: prevLayout,\n                    panelConstraints: panelConstraintsArray,\n                    pivotIndices,\n                    trigger: \"imperative-api\"\n                });\n                if (!compareLayouts(prevLayout, nextLayout)) {\n                    setLayout(nextLayout);\n                    eagerValuesRef.current.layout = nextLayout;\n                    if (onLayout) {\n                        onLayout(nextLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const expandPanel = useCallback((panelData)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        if (panelData.constraints.collapsible) {\n            const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n            const { collapsedSize = 0, panelSize, minSize = 0, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n            if (panelSize === collapsedSize) {\n                // Restore this panel to the size it was before it was collapsed, if possible.\n                const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n                const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n                const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n                const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n                const nextLayout = adjustLayoutByDelta({\n                    delta,\n                    layout: prevLayout,\n                    panelConstraints: panelConstraintsArray,\n                    pivotIndices,\n                    trigger: \"imperative-api\"\n                });\n                if (!compareLayouts(prevLayout, nextLayout)) {\n                    setLayout(nextLayout);\n                    eagerValuesRef.current.layout = nextLayout;\n                    if (onLayout) {\n                        onLayout(nextLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const getPanelSize = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        assert(panelSize != null);\n        return panelSize;\n    }, []);\n    // This API should never read from committedValuesRef\n    const getPanelStyle = useCallback((panelData, defaultSize)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n        return computePanelFlexBoxStyle({\n            defaultSize,\n            dragState,\n            layout,\n            panelData: panelDataArray,\n            panelIndex\n        });\n    }, [\n        dragState,\n        layout\n    ]);\n    // External APIs are safe to memoize via committed values ref\n    const isPanelCollapsed = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        return collapsible === true && panelSize === collapsedSize;\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const isPanelExpanded = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        assert(panelSize != null);\n        return !collapsible || panelSize > collapsedSize;\n    }, []);\n    const registerPanel = useCallback((panelData)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        panelDataArray.push(panelData);\n        panelDataArray.sort((panelA, panelB)=>{\n            const orderA = panelA.order;\n            const orderB = panelB.order;\n            if (orderA == null && orderB == null) {\n                return 0;\n            } else if (orderA == null) {\n                return -1;\n            } else if (orderB == null) {\n                return 1;\n            } else {\n                return orderA - orderB;\n            }\n        });\n        eagerValuesRef.current.panelDataArrayChanged = true;\n    }, []);\n    const registerResizeHandle = useCallback((dragHandleId)=>{\n        return function resizeHandler(event) {\n            event.preventDefault();\n            const panelGroupElement = panelGroupElementRef.current;\n            if (!panelGroupElement) {\n                return ()=>null;\n            }\n            const { direction, dragState, id: groupId, keyboardResizeBy, onLayout } = committedValuesRef.current;\n            const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n            const { initialLayout } = dragState !== null && dragState !== void 0 ? dragState : {};\n            const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n            let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n            if (delta === 0) {\n                return;\n            }\n            // Support RTL layouts\n            const isHorizontal = direction === \"horizontal\";\n            if (document.dir === \"rtl\" && isHorizontal) {\n                delta = -delta;\n            }\n            const panelConstraints = panelDataArray.map((panelData)=>panelData.constraints);\n            const nextLayout = adjustLayoutByDelta({\n                delta,\n                layout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n                panelConstraints,\n                pivotIndices,\n                trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n            });\n            const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n            // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n            // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n            if (isMouseEvent(event) || isTouchEvent(event)) {\n                // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n                // In this case, Panel sizes might not change–\n                // but updating cursor in this scenario would cause a flicker.\n                if (prevDeltaRef.current != delta) {\n                    prevDeltaRef.current = delta;\n                    if (!layoutChanged) {\n                        // If the pointer has moved too far to resize the panel any further,\n                        // update the cursor style for a visual clue.\n                        // This mimics VS Code behavior.\n                        if (isHorizontal) {\n                            setGlobalCursorStyle(delta < 0 ? \"horizontal-min\" : \"horizontal-max\");\n                        } else {\n                            setGlobalCursorStyle(delta < 0 ? \"vertical-min\" : \"vertical-max\");\n                        }\n                    } else {\n                        // Reset the cursor style to the the normal resize cursor.\n                        setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n                    }\n                }\n            }\n            if (layoutChanged) {\n                setLayout(nextLayout);\n                eagerValuesRef.current.layout = nextLayout;\n                if (onLayout) {\n                    onLayout(nextLayout);\n                }\n                callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n            }\n        };\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const resizePanel = useCallback((panelData, unsafePanelSize)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n        const { panelSize, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n        assert(panelSize != null);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: prevLayout,\n            panelConstraints: panelConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n            setLayout(nextLayout);\n            eagerValuesRef.current.layout = nextLayout;\n            if (onLayout) {\n                onLayout(nextLayout);\n            }\n            callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n    }, []);\n    const reevaluatePanelConstraints = useCallback((panelData, prevConstraints)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize: prevCollapsedSize = 0, collapsible: prevCollapsible, defaultSize: prevDefaultSize, maxSize: prevMaxSize = 100, minSize: prevMinSize = 0 } = prevConstraints;\n        const { collapsedSize: nextCollapsedSize = 0, collapsible: nextCollapsible, defaultSize: nextDefaultSize, maxSize: nextMaxSize = 100, minSize: nextMinSize = 0 } = panelData.constraints;\n        const { panelSize: prevPanelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        assert(prevPanelSize != null);\n        if (prevCollapsible && nextCollapsible && prevCollapsedSize !== nextCollapsedSize && prevPanelSize === prevCollapsedSize) {\n            resizePanel(panelData, nextCollapsedSize);\n        } else if (prevPanelSize < nextMinSize) {\n            resizePanel(panelData, nextMinSize);\n        } else if (prevPanelSize > nextMaxSize) {\n            resizePanel(panelData, nextMaxSize);\n        }\n    }, [\n        resizePanel\n    ]);\n    const startDragging = useCallback((dragHandleId, event)=>{\n        const { direction } = committedValuesRef.current;\n        const { layout } = eagerValuesRef.current;\n        if (!panelGroupElementRef.current) {\n            return;\n        }\n        const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n        assert(handleElement);\n        const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n        setDragState({\n            dragHandleId,\n            dragHandleRect: handleElement.getBoundingClientRect(),\n            initialCursorPosition,\n            initialLayout: layout\n        });\n    }, []);\n    const stopDragging = useCallback(()=>{\n        resetGlobalCursorStyle();\n        setDragState(null);\n    }, []);\n    const unregisterPanel = useCallback((panelData)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        const index = findPanelDataIndex(panelDataArray, panelData);\n        if (index >= 0) {\n            panelDataArray.splice(index, 1);\n            // TRICKY\n            // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n            // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n            // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n            delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n            eagerValuesRef.current.panelDataArrayChanged = true;\n        }\n    }, []);\n    const context = useMemo(()=>({\n            collapsePanel,\n            direction,\n            dragState,\n            expandPanel,\n            getPanelSize,\n            getPanelStyle,\n            groupId,\n            isPanelCollapsed,\n            isPanelExpanded,\n            reevaluatePanelConstraints,\n            registerPanel,\n            registerResizeHandle,\n            resizePanel,\n            startDragging,\n            stopDragging,\n            unregisterPanel,\n            panelGroupElement: panelGroupElementRef.current\n        }), [\n        collapsePanel,\n        dragState,\n        direction,\n        expandPanel,\n        getPanelSize,\n        getPanelStyle,\n        groupId,\n        isPanelCollapsed,\n        isPanelExpanded,\n        reevaluatePanelConstraints,\n        registerPanel,\n        registerResizeHandle,\n        resizePanel,\n        startDragging,\n        stopDragging,\n        unregisterPanel\n    ]);\n    const style = {\n        display: \"flex\",\n        flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n        height: \"100%\",\n        overflow: \"hidden\",\n        width: \"100%\"\n    };\n    return createElement(PanelGroupContext.Provider, {\n        value: context\n    }, createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        ref: panelGroupElementRef,\n        // CSS selectors\n        \"data-panel-group\": \"\",\n        \"data-panel-group-direction\": direction,\n        \"data-panel-group-id\": groupId\n    }));\n}\nconst PanelGroup = forwardRef((props, ref)=>createElement(PanelGroupWithForwardedRef, {\n        ...props,\n        forwardedRef: ref\n    }));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n    return panelDataArray.findIndex((prevPanelData)=>prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    const isLastPanel = panelIndex === panelDataArray.length - 1;\n    const pivotIndices = isLastPanel ? [\n        panelIndex - 1,\n        panelIndex\n    ] : [\n        panelIndex,\n        panelIndex + 1\n    ];\n    const panelSize = layout[panelIndex];\n    return {\n        ...panelData.constraints,\n        panelSize,\n        pivotIndices\n    };\n}\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\nfunction useWindowSplitterResizeHandlerBehavior({ disabled, handleId, resizeHandler, panelGroupElement }) {\n    useEffect(()=>{\n        if (disabled || resizeHandler == null || panelGroupElement == null) {\n            return;\n        }\n        const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n        if (handleElement == null) {\n            return;\n        }\n        const onKeyDown = (event)=>{\n            if (event.defaultPrevented) {\n                return;\n            }\n            switch(event.key){\n                case \"ArrowDown\":\n                case \"ArrowLeft\":\n                case \"ArrowRight\":\n                case \"ArrowUp\":\n                case \"End\":\n                case \"Home\":\n                    {\n                        event.preventDefault();\n                        resizeHandler(event);\n                        break;\n                    }\n                case \"F6\":\n                    {\n                        event.preventDefault();\n                        const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n                        assert(groupId);\n                        const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n                        const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n                        assert(index !== null);\n                        const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n                        const nextHandle = handles[nextIndex];\n                        nextHandle.focus();\n                        break;\n                    }\n            }\n        };\n        handleElement.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            handleElement.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        panelGroupElement,\n        disabled,\n        handleId,\n        resizeHandler\n    ]);\n}\nfunction PanelResizeHandle({ children = null, className: classNameFromProps = \"\", disabled = false, id: idFromProps, onDragging, style: styleFromProps = {}, tabIndex = 0, tagName: Type = \"div\", ...rest }) {\n    const elementRef = useRef(null);\n    // Use a ref to guard against users passing inline props\n    const callbacksRef = useRef({\n        onDragging\n    });\n    useEffect(()=>{\n        callbacksRef.current.onDragging = onDragging;\n    });\n    const panelGroupContext = useContext(PanelGroupContext);\n    if (panelGroupContext === null) {\n        throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n    }\n    const { direction, dragState, groupId, registerResizeHandle, startDragging, stopDragging, panelGroupElement } = panelGroupContext;\n    const resizeHandleId = useUniqueId(idFromProps);\n    const isDragging = (dragState === null || dragState === void 0 ? void 0 : dragState.dragHandleId) === resizeHandleId;\n    const [isFocused, setIsFocused] = useState(false);\n    const [resizeHandler, setResizeHandler] = useState(null);\n    const stopDraggingAndBlur = useCallback(()=>{\n        // Clicking on the drag handle shouldn't leave it focused;\n        // That would cause the PanelGroup to think it was still active.\n        const element = elementRef.current;\n        assert(element);\n        element.blur();\n        stopDragging();\n        const { onDragging } = callbacksRef.current;\n        if (onDragging) {\n            onDragging(false);\n        }\n    }, [\n        stopDragging\n    ]);\n    useEffect(()=>{\n        if (disabled) {\n            setResizeHandler(null);\n        } else {\n            const resizeHandler = registerResizeHandle(resizeHandleId);\n            setResizeHandler(()=>resizeHandler);\n        }\n    }, [\n        disabled,\n        resizeHandleId,\n        registerResizeHandle\n    ]);\n    useEffect(()=>{\n        if (disabled || resizeHandler == null || !isDragging) {\n            return;\n        }\n        const onMove = (event)=>{\n            resizeHandler(event);\n        };\n        const onMouseLeave = (event)=>{\n            resizeHandler(event);\n        };\n        const element = elementRef.current;\n        assert(element);\n        const targetDocument = element.ownerDocument;\n        targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n        targetDocument.body.addEventListener(\"mousemove\", onMove);\n        targetDocument.body.addEventListener(\"touchmove\", onMove);\n        targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n        window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n        window.addEventListener(\"touchend\", stopDraggingAndBlur);\n        return ()=>{\n            targetDocument.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n            targetDocument.body.removeEventListener(\"mousemove\", onMove);\n            targetDocument.body.removeEventListener(\"touchmove\", onMove);\n            targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n            window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n            window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n        };\n    }, [\n        direction,\n        disabled,\n        isDragging,\n        resizeHandler,\n        stopDraggingAndBlur\n    ]);\n    useWindowSplitterResizeHandlerBehavior({\n        disabled,\n        handleId: resizeHandleId,\n        resizeHandler,\n        panelGroupElement\n    });\n    const style = {\n        cursor: getCursorStyle(direction),\n        touchAction: \"none\",\n        userSelect: \"none\"\n    };\n    return createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        onBlur: ()=>setIsFocused(false),\n        onFocus: ()=>setIsFocused(true),\n        onMouseDown: (event)=>{\n            startDragging(resizeHandleId, event.nativeEvent);\n            const callbacks = callbacksRef.current;\n            assert(callbacks);\n            const { onDragging } = callbacks;\n            if (onDragging) {\n                onDragging(true);\n            }\n        },\n        onMouseUp: stopDraggingAndBlur,\n        onTouchCancel: stopDraggingAndBlur,\n        onTouchEnd: stopDraggingAndBlur,\n        onTouchStart: (event)=>{\n            startDragging(resizeHandleId, event.nativeEvent);\n            const callbacks = callbacksRef.current;\n            assert(callbacks);\n            const { onDragging } = callbacks;\n            if (onDragging) {\n                onDragging(true);\n            }\n        },\n        ref: elementRef,\n        role: \"separator\",\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        tabIndex,\n        // CSS selectors\n        \"data-panel-group-direction\": direction,\n        \"data-panel-group-id\": groupId,\n        \"data-resize-handle\": \"\",\n        \"data-resize-handle-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n        \"data-panel-resize-handle-enabled\": !disabled,\n        \"data-panel-resize-handle-id\": resizeHandleId\n    });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\nfunction getPanelElement(id, scope = document) {\n    const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getPanelElementsForGroup(groupId, scope = document) {\n    return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlLXBhbmVscy9kaXN0L3JlYWN0LXJlc2l6YWJsZS1wYW5lbHMuZGV2ZWxvcG1lbnQubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUUvQixrR0FBa0c7QUFFbEcsaURBQWlEO0FBRWpELE1BQU0sRUFDSkMsYUFBYSxFQUNiQyxhQUFhLEVBQ2JDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsU0FBUyxFQUNUQyxtQkFBbUIsRUFDbkJDLGVBQWUsRUFDZkMsT0FBTyxFQUNQQyxNQUFNLEVBQ05DLFFBQVEsRUFDVCxHQUFHWixrQ0FBS0E7QUFFVCxnRkFBZ0Y7QUFDaEYsTUFBTWEsUUFBUWIsa0NBQUssQ0FBQyxRQUFRYyxRQUFRLEdBQUc7QUFFdkMsTUFBTUMsb0JBQW9CYixjQUFjO0FBQ3hDYSxrQkFBa0JDLFdBQVcsR0FBRztBQUVoQyxNQUFNQyxlQUFlLE9BQU9KLFVBQVUsYUFBYUEsUUFBUSxJQUFNO0FBQ2pFLElBQUlLLFVBQVU7QUFDZCxTQUFTQyxZQUFZQyxlQUFlLElBQUk7SUFDdEMsTUFBTUMsY0FBY0o7SUFDcEIsTUFBTUssUUFBUVgsT0FBT1MsZ0JBQWdCQyxlQUFlO0lBQ3BELElBQUlDLE1BQU1DLE9BQU8sS0FBSyxNQUFNO1FBQzFCRCxNQUFNQyxPQUFPLEdBQUcsS0FBS0w7SUFDdkI7SUFDQSxPQUFPRSxpQkFBaUIsUUFBUUEsaUJBQWlCLEtBQUssSUFBSUEsZUFBZUUsTUFBTUMsT0FBTztBQUN4RjtBQUVBLFNBQVNDLHNCQUFzQixFQUM3QkMsUUFBUSxFQUNSQyxXQUFXQyxxQkFBcUIsRUFBRSxFQUNsQ0MsYUFBYSxFQUNiQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxJQUFJQyxXQUFXLEVBQ2ZDLE9BQU8sRUFDUEMsT0FBTyxFQUNQQyxVQUFVLEVBQ1ZDLFFBQVEsRUFDUkMsUUFBUSxFQUNS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QjtRQUNaa0IsY0FBY2hOLENBQUFBO1lBQ1pxSyxjQUFjb0IsZ0JBQWdCekwsTUFBTTRNLFdBQVc7WUFDL0MsTUFBTTNULFlBQVlzUyxhQUFhMVUsT0FBTztZQUN0QzBELE9BQU90QjtZQUNQLE1BQU0sRUFDSm1TLFVBQVUsRUFDWCxHQUFHblM7WUFDSixJQUFJbVMsWUFBWTtnQkFDZEEsV0FBVztZQUNiO1FBQ0Y7UUFDQTlRLEtBQUtnUjtRQUNMMkIsTUFBTTtRQUNOblYsT0FBTztZQUNMLEdBQUdBLEtBQUs7WUFDUixHQUFHQyxjQUFjO1FBQ25CO1FBQ0FzVDtRQUNBLGdCQUFnQjtRQUNoQiw4QkFBOEJuSztRQUM5Qix1QkFBdUJ6STtRQUN2QixzQkFBc0I7UUFDdEIsNkJBQTZCaVQsYUFBYSxZQUFZQyxZQUFZLGFBQWF2UztRQUMvRSxvQ0FBb0MsQ0FBQzJSO1FBQ3JDLCtCQUErQlU7SUFDakM7QUFDRjtBQUNBTixrQkFBa0I3VSxXQUFXLEdBQUc7QUFFaEMsU0FBUzRXLGdCQUFnQjVWLEVBQUUsRUFBRStGLFFBQVFDLFFBQVE7SUFDM0MsTUFBTWtCLFVBQVVuQixNQUFNb0IsYUFBYSxDQUFDLENBQUMsZ0JBQWdCLEVBQUVuSCxHQUFHLEVBQUUsQ0FBQztJQUM3RCxJQUFJa0gsU0FBUztRQUNYLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTMk8seUJBQXlCMVUsT0FBTyxFQUFFNEUsUUFBUUMsUUFBUTtJQUN6RCxPQUFPQyxNQUFNQyxJQUFJLENBQUNILE1BQU1JLGdCQUFnQixDQUFDLENBQUMsa0NBQWtDLEVBQUVoRixRQUFRLEVBQUUsQ0FBQztBQUMzRjtBQUV3TyIsInNvdXJjZXMiOlsid2VicGFjazovL3NoYWRjbi1jaGF0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS1wYW5lbHMvZGlzdC9yZWFjdC1yZXNpemFibGUtcGFuZWxzLmRldmVsb3BtZW50Lm5vZGUuZXNtLmpzPzE1NzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vLyBUaGlzIG1vZHVsZSBleGlzdHMgdG8gd29yayBhcm91bmQgV2VicGFjayBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2lzc3Vlcy8xNDgxNFxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5cbmNvbnN0IHtcbiAgY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlQ29udGV4dCxcbiAgY3JlYXRlUmVmLFxuICBmb3J3YXJkUmVmLFxuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlRWZmZWN0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlLFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZU1lbW8sXG4gIHVzZVJlZixcbiAgdXNlU3RhdGVcbn0gPSBSZWFjdDtcblxuLy8gYHRvU3RyaW5nKClgIHByZXZlbnRzIGJ1bmRsZXJzIGZyb20gdHJ5aW5nIHRvIGBpbXBvcnQgeyB1c2VJZCB9IGZyb20gJ3JlYWN0J2BcbmNvbnN0IHVzZUlkID0gUmVhY3RbXCJ1c2VJZFwiLnRvU3RyaW5nKCldO1xuXG5jb25zdCBQYW5lbEdyb3VwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5QYW5lbEdyb3VwQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUGFuZWxHcm91cENvbnRleHRcIjtcblxuY29uc3Qgd3JhcHBlZFVzZUlkID0gdHlwZW9mIHVzZUlkID09PSBcImZ1bmN0aW9uXCIgPyB1c2VJZCA6ICgpID0+IG51bGw7XG5sZXQgY291bnRlciA9IDA7XG5mdW5jdGlvbiB1c2VVbmlxdWVJZChpZEZyb21QYXJhbXMgPSBudWxsKSB7XG4gIGNvbnN0IGlkRnJvbVVzZUlkID0gd3JhcHBlZFVzZUlkKCk7XG4gIGNvbnN0IGlkUmVmID0gdXNlUmVmKGlkRnJvbVBhcmFtcyB8fCBpZEZyb21Vc2VJZCB8fCBudWxsKTtcbiAgaWYgKGlkUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBpZFJlZi5jdXJyZW50ID0gXCJcIiArIGNvdW50ZXIrKztcbiAgfVxuICByZXR1cm4gaWRGcm9tUGFyYW1zICE9PSBudWxsICYmIGlkRnJvbVBhcmFtcyAhPT0gdm9pZCAwID8gaWRGcm9tUGFyYW1zIDogaWRSZWYuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gUGFuZWxXaXRoRm9yd2FyZGVkUmVmKHtcbiAgY2hpbGRyZW4sXG4gIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzID0gXCJcIixcbiAgY29sbGFwc2VkU2l6ZSxcbiAgY29sbGFwc2libGUsXG4gIGRlZmF1bHRTaXplLFxuICBmb3J3YXJkZWRSZWYsXG4gIGlkOiBpZEZyb21Qcm9wcyxcbiAgbWF4U2l6ZSxcbiAgbWluU2l6ZSxcbiAgb25Db2xsYXBzZSxcbiAgb25FeHBhbmQsXG4gIG9uUmVzaXplLFxuICBvcmRlcixcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzLFxuICB0YWdOYW1lOiBUeXBlID0gXCJkaXZcIixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChQYW5lbEdyb3VwQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhbmVsIGNvbXBvbmVudHMgbXVzdCBiZSByZW5kZXJlZCB3aXRoaW4gYSBQYW5lbEdyb3VwIGNvbnRhaW5lcmApO1xuICB9XG4gIGNvbnN0IHtcbiAgICBjb2xsYXBzZVBhbmVsLFxuICAgIGV4cGFuZFBhbmVsLFxuICAgIGdldFBhbmVsU2l6ZSxcbiAgICBnZXRQYW5lbFN0eWxlLFxuICAgIGdyb3VwSWQsXG4gICAgaXNQYW5lbENvbGxhcHNlZCxcbiAgICByZWV2YWx1YXRlUGFuZWxDb25zdHJhaW50cyxcbiAgICByZWdpc3RlclBhbmVsLFxuICAgIHJlc2l6ZVBhbmVsLFxuICAgIHVucmVnaXN0ZXJQYW5lbFxuICB9ID0gY29udGV4dDtcbiAgY29uc3QgcGFuZWxJZCA9IHVzZVVuaXF1ZUlkKGlkRnJvbVByb3BzKTtcbiAgY29uc3QgcGFuZWxEYXRhUmVmID0gdXNlUmVmKHtcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIG9uQ29sbGFwc2UsXG4gICAgICBvbkV4cGFuZCxcbiAgICAgIG9uUmVzaXplXG4gICAgfSxcbiAgICBjb25zdHJhaW50czoge1xuICAgICAgY29sbGFwc2VkU2l6ZSxcbiAgICAgIGNvbGxhcHNpYmxlLFxuICAgICAgZGVmYXVsdFNpemUsXG4gICAgICBtYXhTaXplLFxuICAgICAgbWluU2l6ZVxuICAgIH0sXG4gICAgaWQ6IHBhbmVsSWQsXG4gICAgaWRJc0Zyb21Qcm9wczogaWRGcm9tUHJvcHMgIT09IHVuZGVmaW5lZCxcbiAgICBvcmRlclxuICB9KTtcbiAgY29uc3QgZGV2V2FybmluZ3NSZWYgPSB1c2VSZWYoe1xuICAgIGRpZExvZ01pc3NpbmdEZWZhdWx0U2l6ZVdhcm5pbmc6IGZhbHNlXG4gIH0pO1xuXG4gIC8vIE5vcm1hbGx5IHdlIHdvdWxkbid0IGxvZyBhIHdhcm5pbmcgZHVyaW5nIHJlbmRlcixcbiAgLy8gYnV0IGVmZmVjdHMgZG9uJ3QgcnVuIG9uIHRoZSBzZXJ2ZXIsIHNvIHdlIGNhbid0IGRvIGl0IHRoZXJlXG4gIHtcbiAgICBpZiAoIWRldldhcm5pbmdzUmVmLmN1cnJlbnQuZGlkTG9nTWlzc2luZ0RlZmF1bHRTaXplV2FybmluZykge1xuICAgICAgaWYgKGRlZmF1bHRTaXplID09IG51bGwpIHtcbiAgICAgICAgZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dNaXNzaW5nRGVmYXVsdFNpemVXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBQYW5lbCBkZWZhdWx0U2l6ZSBwcm9wIHJlY29tbWVuZGVkIHRvIGF2b2lkIGxheW91dCBzaGlmdCBhZnRlciBzZXJ2ZXIgcmVuZGVyaW5nYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiAoe1xuICAgIGNvbGxhcHNlOiAoKSA9PiB7XG4gICAgICBjb2xsYXBzZVBhbmVsKHBhbmVsRGF0YVJlZi5jdXJyZW50KTtcbiAgICB9LFxuICAgIGV4cGFuZDogKCkgPT4ge1xuICAgICAgZXhwYW5kUGFuZWwocGFuZWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgIH0sXG4gICAgZ2V0SWQoKSB7XG4gICAgICByZXR1cm4gcGFuZWxJZDtcbiAgICB9LFxuICAgIGdldFNpemUoKSB7XG4gICAgICByZXR1cm4gZ2V0UGFuZWxTaXplKHBhbmVsRGF0YVJlZi5jdXJyZW50KTtcbiAgICB9LFxuICAgIGlzQ29sbGFwc2VkKCkge1xuICAgICAgcmV0dXJuIGlzUGFuZWxDb2xsYXBzZWQocGFuZWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgIH0sXG4gICAgaXNFeHBhbmRlZCgpIHtcbiAgICAgIHJldHVybiAhaXNQYW5lbENvbGxhcHNlZChwYW5lbERhdGFSZWYuY3VycmVudCk7XG4gICAgfSxcbiAgICByZXNpemU6IHNpemUgPT4ge1xuICAgICAgcmVzaXplUGFuZWwocGFuZWxEYXRhUmVmLmN1cnJlbnQsIHNpemUpO1xuICAgIH1cbiAgfSksIFtjb2xsYXBzZVBhbmVsLCBleHBhbmRQYW5lbCwgZ2V0UGFuZWxTaXplLCBpc1BhbmVsQ29sbGFwc2VkLCBwYW5lbElkLCByZXNpemVQYW5lbF0pO1xuICBjb25zdCBzdHlsZSA9IGdldFBhbmVsU3R5bGUocGFuZWxEYXRhUmVmLmN1cnJlbnQsIGRlZmF1bHRTaXplKTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVHlwZSwge1xuICAgIC4uLnJlc3QsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIC8vIENTUyBzZWxlY3RvcnNcbiAgICBcImRhdGEtcGFuZWxcIjogXCJcIixcbiAgICBcImRhdGEtcGFuZWwtaWRcIjogcGFuZWxJZCxcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIjogZ3JvdXBJZCxcbiAgICAvLyBlMmUgdGVzdCBhdHRyaWJ1dGVzXG4gICAgXCJkYXRhLXBhbmVsLWNvbGxhcHNpYmxlXCI6IGNvbGxhcHNpYmxlIHx8IHVuZGVmaW5lZCAsXG4gICAgXCJkYXRhLXBhbmVsLXNpemVcIjogcGFyc2VGbG9hdChcIlwiICsgc3R5bGUuZmxleEdyb3cpLnRvRml4ZWQoMSkgXG4gIH0pO1xufVxuY29uc3QgUGFuZWwgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiBjcmVhdGVFbGVtZW50KFBhbmVsV2l0aEZvcndhcmRlZFJlZiwge1xuICAuLi5wcm9wcyxcbiAgZm9yd2FyZGVkUmVmOiByZWZcbn0pKTtcblBhbmVsV2l0aEZvcndhcmRlZFJlZi5kaXNwbGF5TmFtZSA9IFwiUGFuZWxcIjtcblBhbmVsLmRpc3BsYXlOYW1lID0gXCJmb3J3YXJkUmVmKFBhbmVsKVwiO1xuXG5mdW5jdGlvbiBhc3NlcnQoZXhwZWN0ZWRDb25kaXRpb24sIG1lc3NhZ2UgPSBcIkFzc2VydGlvbiBmYWlsZWQhXCIpIHtcbiAgaWYgKCFleHBlY3RlZENvbmRpdGlvbikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgdGhyb3cgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuY29uc3QgUFJFQ0lTSU9OID0gMTA7XG5cbmZ1bmN0aW9uIGZ1enp5Q29tcGFyZU51bWJlcnMoYWN0dWFsLCBleHBlY3RlZCwgZnJhY3Rpb25EaWdpdHMgPSBQUkVDSVNJT04pIHtcbiAgYWN0dWFsID0gcGFyc2VGbG9hdChhY3R1YWwudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICBleHBlY3RlZCA9IHBhcnNlRmxvYXQoZXhwZWN0ZWQudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICBjb25zdCBkZWx0YSA9IGFjdHVhbCAtIGV4cGVjdGVkO1xuICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gMSA6IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZ1enp5TnVtYmVyc0VxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZyYWN0aW9uRGlnaXRzKSB7XG4gIHJldHVybiBmdXp6eUNvbXBhcmVOdW1iZXJzKGFjdHVhbCwgZXhwZWN0ZWQsIGZyYWN0aW9uRGlnaXRzKSA9PT0gMDtcbn1cblxuLy8gUGFuZWwgc2l6ZSBtdXN0IGJlIGluIHBlcmNlbnRhZ2VzOyBwaXhlbCB2YWx1ZXMgc2hvdWxkIGJlIHByZS1jb252ZXJ0ZWRcbmZ1bmN0aW9uIHJlc2l6ZVBhbmVsKHtcbiAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICBwYW5lbEluZGV4LFxuICBzaXplXG59KSB7XG4gIGNvbnN0IHBhbmVsQ29uc3RyYWludHMgPSBwYW5lbENvbnN0cmFpbnRzQXJyYXlbcGFuZWxJbmRleF07XG4gIGFzc2VydChwYW5lbENvbnN0cmFpbnRzICE9IG51bGwpO1xuICBsZXQge1xuICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgIGNvbGxhcHNpYmxlLFxuICAgIG1heFNpemUgPSAxMDAsXG4gICAgbWluU2l6ZSA9IDBcbiAgfSA9IHBhbmVsQ29uc3RyYWludHM7XG4gIGlmIChmdXp6eUNvbXBhcmVOdW1iZXJzKHNpemUsIG1pblNpemUpIDwgMCkge1xuICAgIGlmIChjb2xsYXBzaWJsZSkge1xuICAgICAgLy8gQ29sbGFwc2libGUgcGFuZWxzIHNob3VsZCBzbmFwIGNsb3NlZCBvciBvcGVuIG9ubHkgb25jZSB0aGV5IGNyb3NzIHRoZSBoYWxmd2F5IHBvaW50IGJldHdlZW4gY29sbGFwc2VkIGFuZCBtaW4gc2l6ZS5cbiAgICAgIGNvbnN0IGhhbGZ3YXlQb2ludCA9IChjb2xsYXBzZWRTaXplICsgbWluU2l6ZSkgLyAyO1xuICAgICAgaWYgKGZ1enp5Q29tcGFyZU51bWJlcnMoc2l6ZSwgaGFsZndheVBvaW50KSA8IDApIHtcbiAgICAgICAgc2l6ZSA9IGNvbGxhcHNlZFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbWluU2l6ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IG1pblNpemU7XG4gICAgfVxuICB9XG4gIHNpemUgPSBNYXRoLm1pbihtYXhTaXplLCBzaXplKTtcbiAgc2l6ZSA9IHBhcnNlRmxvYXQoc2l6ZS50b0ZpeGVkKFBSRUNJU0lPTikpO1xuICByZXR1cm4gc2l6ZTtcbn1cblxuLy8gQWxsIHVuaXRzIG11c3QgYmUgaW4gcGVyY2VudGFnZXM7IHBpeGVsIHZhbHVlcyBzaG91bGQgYmUgcHJlLWNvbnZlcnRlZFxuZnVuY3Rpb24gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gIGRlbHRhLFxuICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgcGl2b3RJbmRpY2VzLFxuICB0cmlnZ2VyXG59KSB7XG4gIGlmIChmdXp6eU51bWJlcnNFcXVhbChkZWx0YSwgMCkpIHtcbiAgICByZXR1cm4gcHJldkxheW91dDtcbiAgfVxuICBjb25zdCBuZXh0TGF5b3V0ID0gWy4uLnByZXZMYXlvdXRdO1xuICBjb25zdCBbZmlyc3RQaXZvdEluZGV4LCBzZWNvbmRQaXZvdEluZGV4XSA9IHBpdm90SW5kaWNlcztcbiAgYXNzZXJ0KGZpcnN0UGl2b3RJbmRleCAhPSBudWxsKTtcbiAgYXNzZXJ0KHNlY29uZFBpdm90SW5kZXggIT0gbnVsbCk7XG4gIGxldCBkZWx0YUFwcGxpZWQgPSAwO1xuXG4gIC8vY29uc3QgREVCVUcgPSBbXTtcbiAgLy9ERUJVRy5wdXNoKGBhZGp1c3RMYXlvdXRCeURlbHRhKCkgJHtwcmV2TGF5b3V0LmpvaW4oXCIsIFwiKX1gKTtcbiAgLy9ERUJVRy5wdXNoKGAgIGRlbHRhOiAke2RlbHRhfWApO1xuICAvL0RFQlVHLnB1c2goYCAgcGl2b3RJbmRpY2VzOiAke3Bpdm90SW5kaWNlcy5qb2luKFwiLCBcIil9YCk7XG4gIC8vREVCVUcucHVzaChgICB0cmlnZ2VyOiAke3RyaWdnZXJ9YCk7XG4gIC8vREVCVUcucHVzaChcIlwiKTtcblxuICAvLyBBIHJlc2l6aW5nIHBhbmVsIGFmZmVjdHMgdGhlIHBhbmVscyBiZWZvcmUgb3IgYWZ0ZXIgaXQuXG4gIC8vXG4gIC8vIEEgbmVnYXRpdmUgZGVsdGEgbWVhbnMgdGhlIHBhbmVsKHMpIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSByZXNpemUgaGFuZGxlIHNob3VsZCBncm93L2V4cGFuZCBieSBkZWNyZWFzaW5nIGl0cyBvZmZzZXQuXG4gIC8vIE90aGVyIHBhbmVscyBtYXkgYWxzbyBuZWVkIHRvIHNocmluay9jb250cmFjdCAoYW5kIHNoaWZ0KSB0byBtYWtlIHJvb20sIGRlcGVuZGluZyBvbiB0aGUgbWluIHdlaWdodHMuXG4gIC8vXG4gIC8vIEEgcG9zaXRpdmUgZGVsdGEgbWVhbnMgdGhlIHBhbmVsKHMpIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgcmVzaXplIGhhbmRsZSBzaG91bGQgXCJleHBhbmRcIi5cbiAgLy8gVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgc2hyaW5raW5nL2NvbnRyYWN0aW5nIChhbmQgc2hpZnRpbmcpIG9uZSBvciBtb3JlIG9mIHRoZSBwYW5lbHMgYWZ0ZXIgdGhlIHJlc2l6ZSBoYW5kbGUuXG5cbiAge1xuICAgIC8vIElmIHRoaXMgaXMgYSByZXNpemUgdHJpZ2dlcmVkIGJ5IGEga2V5Ym9hcmQgZXZlbnQsIG91ciBsb2dpYyBmb3IgZXhwYW5kaW5nL2NvbGxhcHNpbmcgaXMgZGlmZmVyZW50LlxuICAgIC8vIFdlIG5vIGxvbmdlciBjaGVjayB0aGUgaGFsZndheSB0aHJlc2hvbGQgYmVjYXVzZSB0aGlzIG1heSBwcmV2ZW50IHRoZSBwYW5lbCBmcm9tIGV4cGFuZGluZyBhdCBhbGwuXG4gICAgaWYgKHRyaWdnZXIgPT09IFwia2V5Ym9hcmRcIikge1xuICAgICAge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgZXhwYW5kIGEgY29sbGFwc2VkIHBhbmVsXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGVsdGEgPCAwID8gc2Vjb25kUGl2b3RJbmRleCA6IGZpcnN0UGl2b3RJbmRleDtcbiAgICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsQ29uc3RyYWludHNBcnJheVtpbmRleF07XG4gICAgICAgIGFzc2VydChwYW5lbENvbnN0cmFpbnRzKTtcblxuICAgICAgICAvL0RFQlVHLnB1c2goYGVkZ2UgY2FzZSBjaGVjayAxOiAke2luZGV4fWApO1xuICAgICAgICAvL0RFQlVHLnB1c2goYCAgLT4gY29sbGFwc2libGU/ICR7Y29uc3RyYWludHMuY29sbGFwc2libGV9YCk7XG4gICAgICAgIGlmIChwYW5lbENvbnN0cmFpbnRzLmNvbGxhcHNpYmxlKSB7XG4gICAgICAgICAgY29uc3QgcHJldlNpemUgPSBwcmV2TGF5b3V0W2luZGV4XTtcbiAgICAgICAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCk7XG4gICAgICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsQ29uc3RyYWludHNBcnJheVtpbmRleF07XG4gICAgICAgICAgYXNzZXJ0KHBhbmVsQ29uc3RyYWludHMpO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgICAgICAgbWluU2l6ZSA9IDBcbiAgICAgICAgICB9ID0gcGFuZWxDb25zdHJhaW50cztcbiAgICAgICAgICBpZiAoZnV6enlOdW1iZXJzRXF1YWwocHJldlNpemUsIGNvbGxhcHNlZFNpemUpKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbERlbHRhID0gbWluU2l6ZSAtIHByZXZTaXplO1xuICAgICAgICAgICAgLy9ERUJVRy5wdXNoKGAgIC0+IGV4cGFuZCBkZWx0YTogJHtsb2NhbERlbHRhfWApO1xuXG4gICAgICAgICAgICBpZiAoZnV6enlDb21wYXJlTnVtYmVycyhsb2NhbERlbHRhLCBNYXRoLmFicyhkZWx0YSkpID4gMCkge1xuICAgICAgICAgICAgICBkZWx0YSA9IGRlbHRhIDwgMCA/IDAgLSBsb2NhbERlbHRhIDogbG9jYWxEZWx0YTtcbiAgICAgICAgICAgICAgLy9ERUJVRy5wdXNoKGAgIC0+IGRlbHRhOiAke2RlbHRhfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBhIHBhbmVsIGF0IGl0cyBtaW5pbXVtIHNpemVcbiAgICAgICAgY29uc3QgaW5kZXggPSBkZWx0YSA8IDAgPyBmaXJzdFBpdm90SW5kZXggOiBzZWNvbmRQaXZvdEluZGV4O1xuICAgICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxDb25zdHJhaW50c0FycmF5W2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KHBhbmVsQ29uc3RyYWludHMpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29sbGFwc2libGVcbiAgICAgICAgfSA9IHBhbmVsQ29uc3RyYWludHM7XG5cbiAgICAgICAgLy9ERUJVRy5wdXNoKGBlZGdlIGNhc2UgY2hlY2sgMjogJHtpbmRleH1gKTtcbiAgICAgICAgLy9ERUJVRy5wdXNoKGAgIC0+IGNvbGxhcHNpYmxlPyAke2NvbGxhcHNpYmxlfWApO1xuICAgICAgICBpZiAoY29sbGFwc2libGUpIHtcbiAgICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IHByZXZMYXlvdXRbaW5kZXhdO1xuICAgICAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsKTtcbiAgICAgICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxDb25zdHJhaW50c0FycmF5W2luZGV4XTtcbiAgICAgICAgICBhc3NlcnQocGFuZWxDb25zdHJhaW50cyk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgICAgICBtaW5TaXplID0gMFxuICAgICAgICAgIH0gPSBwYW5lbENvbnN0cmFpbnRzO1xuICAgICAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbChwcmV2U2l6ZSwgbWluU2l6ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsRGVsdGEgPSBwcmV2U2l6ZSAtIGNvbGxhcHNlZFNpemU7XG4gICAgICAgICAgICAvL0RFQlVHLnB1c2goYCAgLT4gZXhwYW5kIGRlbHRhOiAke2xvY2FsRGVsdGF9YCk7XG5cbiAgICAgICAgICAgIGlmIChmdXp6eUNvbXBhcmVOdW1iZXJzKGxvY2FsRGVsdGEsIE1hdGguYWJzKGRlbHRhKSkgPiAwKSB7XG4gICAgICAgICAgICAgIGRlbHRhID0gZGVsdGEgPCAwID8gMCAtIGxvY2FsRGVsdGEgOiBsb2NhbERlbHRhO1xuICAgICAgICAgICAgICAvL0RFQlVHLnB1c2goYCAgLT4gZGVsdGE6ICR7ZGVsdGF9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vREVCVUcucHVzaChcIlwiKTtcbiAgfVxuXG4gIHtcbiAgICAvLyBQcmUtY2FsY3VsYXRlIG1heCBhdmFpbGFibGUgZGVsdGEgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBvZiBvdXIgcGl2b3QuXG4gICAgLy8gVGhpcyB3aWxsIGJlIHRoZSBtYXhpbXVtIGFtb3VudCB3ZSdyZSBhbGxvd2VkIHRvIGV4cGFuZC9jb250cmFjdCB0aGUgcGFuZWxzIGluIHRoZSBwcmltYXJ5IGRpcmVjdGlvbi5cbiAgICAvLyBJZiB0aGlzIGFtb3VudCBpcyBsZXNzIHRoYW4gdGhlIHJlcXVlc3RlZCBkZWx0YSwgYWRqdXN0IHRoZSByZXF1ZXN0ZWQgZGVsdGEuXG4gICAgLy8gSWYgdGhpcyBhbW91bnQgaXMgZ3JlYXRlciB0aGFuIHRoZSByZXF1ZXN0ZWQgZGVsdGEsIHRoYXQncyB1c2VmdWwgaW5mb3JtYXRpb24gdG9v4oCTXG4gICAgLy8gYXMgYW4gZXhwYW5kaW5nIHBhbmVsIG1pZ2h0IGNoYW5nZSBmcm9tIGNvbGxhcHNlZCB0byBtaW4gc2l6ZS5cblxuICAgIGNvbnN0IGluY3JlbWVudCA9IGRlbHRhIDwgMCA/IDEgOiAtMTtcbiAgICBsZXQgaW5kZXggPSBkZWx0YSA8IDAgPyBzZWNvbmRQaXZvdEluZGV4IDogZmlyc3RQaXZvdEluZGV4O1xuICAgIGxldCBtYXhBdmFpbGFibGVEZWx0YSA9IDA7XG5cbiAgICAvL0RFQlVHLnB1c2goXCJwcmUgY2FsYy4uLlwiKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgcHJldlNpemUgPSBwcmV2TGF5b3V0W2luZGV4XTtcbiAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsKTtcbiAgICAgIGNvbnN0IG1heFNhZmVTaXplID0gcmVzaXplUGFuZWwoe1xuICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICAgIHBhbmVsSW5kZXg6IGluZGV4LFxuICAgICAgICBzaXplOiAxMDBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGVsdGEgPSBtYXhTYWZlU2l6ZSAtIHByZXZTaXplO1xuICAgICAgLy9ERUJVRy5wdXNoKGAgICR7aW5kZXh9OiAke3ByZXZTaXplfSAtPiAke21heFNhZmVTaXplfWApO1xuXG4gICAgICBtYXhBdmFpbGFibGVEZWx0YSArPSBkZWx0YTtcbiAgICAgIGluZGV4ICs9IGluY3JlbWVudDtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gcGFuZWxDb25zdHJhaW50c0FycmF5Lmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0RFQlVHLnB1c2goYCAgLT4gbWF4IGF2YWlsYWJsZSBkZWx0YTogJHttYXhBdmFpbGFibGVEZWx0YX1gKTtcbiAgICBjb25zdCBtaW5BYnNEZWx0YSA9IE1hdGgubWluKE1hdGguYWJzKGRlbHRhKSwgTWF0aC5hYnMobWF4QXZhaWxhYmxlRGVsdGEpKTtcbiAgICBkZWx0YSA9IGRlbHRhIDwgMCA/IDAgLSBtaW5BYnNEZWx0YSA6IG1pbkFic0RlbHRhO1xuICAgIC8vREVCVUcucHVzaChgICAtPiBhZGp1c3RlZCBkZWx0YTogJHtkZWx0YX1gKTtcbiAgICAvL0RFQlVHLnB1c2goXCJcIik7XG4gIH1cblxuICB7XG4gICAgLy8gRGVsdGEgYWRkZWQgdG8gYSBwYW5lbCBuZWVkcyB0byBiZSBzdWJ0cmFjdGVkIGZyb20gb3RoZXIgcGFuZWxzICh3aXRoaW4gdGhlIGNvbnN0cmFpbnRzIHRoYXQgdGhvc2UgcGFuZWxzIGFsbG93KS5cblxuICAgIGNvbnN0IHBpdm90SW5kZXggPSBkZWx0YSA8IDAgPyBmaXJzdFBpdm90SW5kZXggOiBzZWNvbmRQaXZvdEluZGV4O1xuICAgIGxldCBpbmRleCA9IHBpdm90SW5kZXg7XG4gICAgd2hpbGUgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwYW5lbENvbnN0cmFpbnRzQXJyYXkubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZWx0YVJlbWFpbmluZyA9IE1hdGguYWJzKGRlbHRhKSAtIE1hdGguYWJzKGRlbHRhQXBwbGllZCk7XG4gICAgICBjb25zdCBwcmV2U2l6ZSA9IHByZXZMYXlvdXRbaW5kZXhdO1xuICAgICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwpO1xuICAgICAgY29uc3QgdW5zYWZlU2l6ZSA9IHByZXZTaXplIC0gZGVsdGFSZW1haW5pbmc7XG4gICAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgICBwYW5lbEluZGV4OiBpbmRleCxcbiAgICAgICAgc2l6ZTogdW5zYWZlU2l6ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsKHByZXZTaXplLCBzYWZlU2l6ZSkpIHtcbiAgICAgICAgZGVsdGFBcHBsaWVkICs9IHByZXZTaXplIC0gc2FmZVNpemU7XG4gICAgICAgIG5leHRMYXlvdXRbaW5kZXhdID0gc2FmZVNpemU7XG4gICAgICAgIGlmIChkZWx0YUFwcGxpZWQudG9QcmVjaXNpb24oMykubG9jYWxlQ29tcGFyZShNYXRoLmFicyhkZWx0YSkudG9QcmVjaXNpb24oMyksIHVuZGVmaW5lZCwge1xuICAgICAgICAgIG51bWVyaWM6IHRydWVcbiAgICAgICAgfSkgPj0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0RFQlVHLnB1c2goYGFmdGVyIDE6ICR7bmV4dExheW91dC5qb2luKFwiLCBcIil9YCk7XG4gIC8vREVCVUcucHVzaChgICBkZWx0YUFwcGxpZWQ6ICR7ZGVsdGFBcHBsaWVkfWApO1xuICAvL0RFQlVHLnB1c2goXCJcIik7XG5cbiAgLy8gSWYgd2Ugd2VyZSB1bmFibGUgdG8gcmVzaXplIGFueSBvZiB0aGUgcGFuZWxzIHBhbmVscywgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgLy8gVGhpcyB3aWxsIGVzc2VudGlhbGx5IGJhaWxvdXQgYW5kIGlnbm9yZSBlLmcuIGRyYWdzIHBhc3QgYSBwYW5lbCdzIGJvdW5kYXJpZXNcbiAgaWYgKGZ1enp5TnVtYmVyc0VxdWFsKGRlbHRhQXBwbGllZCwgMCkpIHtcbiAgICAvL2NvbnNvbGUubG9nKERFQlVHLmpvaW4oXCJcXG5cIikpO1xuICAgIHJldHVybiBwcmV2TGF5b3V0O1xuICB9XG4gIHtcbiAgICAvLyBOb3cgZGlzdHJpYnV0ZSB0aGUgYXBwbGllZCBkZWx0YSB0byB0aGUgcGFuZWxzIGluIHRoZSBvdGhlciBkaXJlY3Rpb25cbiAgICBjb25zdCBwaXZvdEluZGV4ID0gZGVsdGEgPCAwID8gc2Vjb25kUGl2b3RJbmRleCA6IGZpcnN0UGl2b3RJbmRleDtcbiAgICBjb25zdCBwcmV2U2l6ZSA9IHByZXZMYXlvdXRbcGl2b3RJbmRleF07XG4gICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwpO1xuICAgIGNvbnN0IHVuc2FmZVNpemUgPSBwcmV2U2l6ZSArIGRlbHRhQXBwbGllZDtcbiAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgIHBhbmVsSW5kZXg6IHBpdm90SW5kZXgsXG4gICAgICBzaXplOiB1bnNhZmVTaXplXG4gICAgfSk7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBpdm90IHBhbmVsIGJlZm9yZSwgYnV0IG9ubHkgYnkgdGhlIGFtb3VudCB0aGF0IHN1cnJvdW5kaW5nIHBhbmVscyB3ZXJlIGFibGUgdG8gc2hyaW5rL2NvbnRyYWN0LlxuICAgIG5leHRMYXlvdXRbcGl2b3RJbmRleF0gPSBzYWZlU2l6ZTtcblxuICAgIC8vIEVkZ2UgY2FzZSB3aGVyZSBleHBhbmRpbmcgb3IgY29udHJhY3Rpbmcgb25lIHBhbmVsIGNhdXNlZCBhbm90aGVyIG9uZSB0byBjaGFuZ2UgY29sbGFwc2VkIHN0YXRlXG4gICAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChzYWZlU2l6ZSwgdW5zYWZlU2l6ZSkpIHtcbiAgICAgIGxldCBkZWx0YVJlbWFpbmluZyA9IHVuc2FmZVNpemUgLSBzYWZlU2l6ZTtcbiAgICAgIGNvbnN0IHBpdm90SW5kZXggPSBkZWx0YSA8IDAgPyBzZWNvbmRQaXZvdEluZGV4IDogZmlyc3RQaXZvdEluZGV4O1xuICAgICAgbGV0IGluZGV4ID0gcGl2b3RJbmRleDtcbiAgICAgIHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDwgcGFuZWxDb25zdHJhaW50c0FycmF5Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IG5leHRMYXlvdXRbaW5kZXhdO1xuICAgICAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IHVuc2FmZVNpemUgPSBwcmV2U2l6ZSArIGRlbHRhUmVtYWluaW5nO1xuICAgICAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICAgICAgcGFuZWxJbmRleDogaW5kZXgsXG4gICAgICAgICAgc2l6ZTogdW5zYWZlU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChwcmV2U2l6ZSwgc2FmZVNpemUpKSB7XG4gICAgICAgICAgZGVsdGFSZW1haW5pbmcgLT0gc2FmZVNpemUgLSBwcmV2U2l6ZTtcbiAgICAgICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbChkZWx0YVJlbWFpbmluZywgMCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vREVCVUcucHVzaChgYWZ0ZXIgMjogJHtuZXh0TGF5b3V0LmpvaW4oXCIsIFwiKX1gKTtcbiAgLy9ERUJVRy5wdXNoKGAgIGRlbHRhQXBwbGllZDogJHtkZWx0YUFwcGxpZWR9YCk7XG4gIC8vREVCVUcucHVzaChcIlwiKTtcblxuICBjb25zdCB0b3RhbFNpemUgPSBuZXh0TGF5b3V0LnJlZHVjZSgodG90YWwsIHNpemUpID0+IHNpemUgKyB0b3RhbCwgMCk7XG4gIC8vREVCVUcucHVzaChgdG90YWwgc2l6ZTogJHt0b3RhbFNpemV9YCk7XG4gIC8vY29uc29sZS5sb2coREVCVUcuam9pbihcIlxcblwiKSk7XG5cbiAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbCh0b3RhbFNpemUsIDEwMCkpIHtcbiAgICByZXR1cm4gcHJldkxheW91dDtcbiAgfVxuICByZXR1cm4gbmV4dExheW91dDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cChncm91cElkLCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRdW2RhdGEtcGFuZWwtZ3JvdXAtaWQ9XCIke2dyb3VwSWR9XCJdYCkpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVFbGVtZW50SW5kZXgoZ3JvdXBJZCwgaWQsIHNjb3BlID0gZG9jdW1lbnQpIHtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRzRm9yR3JvdXAoZ3JvdXBJZCwgc2NvcGUpO1xuICBjb25zdCBpbmRleCA9IGhhbmRsZXMuZmluZEluZGV4KGhhbmRsZSA9PiBoYW5kbGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXCIpID09PSBpZCk7XG4gIHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCAhPT0gdm9pZCAwID8gaW5kZXggOiBudWxsO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVQaXZvdEluZGljZXMoZ3JvdXBJZCwgZHJhZ0hhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCkge1xuICBjb25zdCBpbmRleCA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRJbmRleChncm91cElkLCBkcmFnSGFuZGxlSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgcmV0dXJuIGluZGV4ICE9IG51bGwgPyBbaW5kZXgsIGluZGV4ICsgMV0gOiBbLTEsIC0xXTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFuZWxHcm91cEVsZW1lbnQoaWQsIHJvb3RFbGVtZW50ID0gZG9jdW1lbnQpIHtcbiAgdmFyIF9kYXRhc2V0O1xuICAvL0lmIHRoZSByb290IGVsZW1lbnQgaXMgdGhlIFBhbmVsR3JvdXBcbiAgaWYgKHJvb3RFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKHJvb3RFbGVtZW50ID09PSBudWxsIHx8IHJvb3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2RhdGFzZXQgPSByb290RWxlbWVudC5kYXRhc2V0KSA9PT0gbnVsbCB8fCBfZGF0YXNldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGFzZXQucGFuZWxHcm91cElkKSA9PSBpZCkge1xuICAgIHJldHVybiByb290RWxlbWVudDtcbiAgfVxuXG4gIC8vRWxzZSBxdWVyeSBjaGlsZHJlblxuICBjb25zdCBlbGVtZW50ID0gcm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcGFuZWwtZ3JvdXBdW2RhdGEtcGFuZWwtZ3JvdXAtaWQ9XCIke2lkfVwiXWApO1xuICBpZiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVFbGVtZW50KGlkLCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBzY29wZS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkPVwiJHtpZH1cIl1gKTtcbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMoZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsc0FycmF5LCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIHZhciBfcGFuZWxzQXJyYXkkaW5kZXgkaWQsIF9wYW5lbHNBcnJheSRpbmRleCwgX3BhbmVsc0FycmF5JGlkLCBfcGFuZWxzQXJyYXk7XG4gIGNvbnN0IGhhbmRsZSA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnQoaGFuZGxlSWQsIHNjb3BlKTtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRzRm9yR3JvdXAoZ3JvdXBJZCwgc2NvcGUpO1xuICBjb25zdCBpbmRleCA9IGhhbmRsZSA/IGhhbmRsZXMuaW5kZXhPZihoYW5kbGUpIDogLTE7XG4gIGNvbnN0IGlkQmVmb3JlID0gKF9wYW5lbHNBcnJheSRpbmRleCRpZCA9IChfcGFuZWxzQXJyYXkkaW5kZXggPSBwYW5lbHNBcnJheVtpbmRleF0pID09PSBudWxsIHx8IF9wYW5lbHNBcnJheSRpbmRleCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BhbmVsc0FycmF5JGluZGV4LmlkKSAhPT0gbnVsbCAmJiBfcGFuZWxzQXJyYXkkaW5kZXgkaWQgIT09IHZvaWQgMCA/IF9wYW5lbHNBcnJheSRpbmRleCRpZCA6IG51bGw7XG4gIGNvbnN0IGlkQWZ0ZXIgPSAoX3BhbmVsc0FycmF5JGlkID0gKF9wYW5lbHNBcnJheSA9IHBhbmVsc0FycmF5W2luZGV4ICsgMV0pID09PSBudWxsIHx8IF9wYW5lbHNBcnJheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BhbmVsc0FycmF5LmlkKSAhPT0gbnVsbCAmJiBfcGFuZWxzQXJyYXkkaWQgIT09IHZvaWQgMCA/IF9wYW5lbHNBcnJheSRpZCA6IG51bGw7XG4gIHJldHVybiBbaWRCZWZvcmUsIGlkQWZ0ZXJdO1xufVxuXG4vLyBodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL3dpbmRvd3NwbGl0dGVyL1xuXG5mdW5jdGlvbiB1c2VXaW5kb3dTcGxpdHRlclBhbmVsR3JvdXBCZWhhdmlvcih7XG4gIGNvbW1pdHRlZFZhbHVlc1JlZixcbiAgZWFnZXJWYWx1ZXNSZWYsXG4gIGdyb3VwSWQsXG4gIGxheW91dCxcbiAgcGFuZWxEYXRhQXJyYXksXG4gIHBhbmVsR3JvdXBFbGVtZW50LFxuICBzZXRMYXlvdXRcbn0pIHtcbiAgdXNlUmVmKHtcbiAgICBkaWRXYXJuQWJvdXRNaXNzaW5nUmVzaXplSGFuZGxlOiBmYWxzZVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXBhbmVsR3JvdXBFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVhZ2VyVmFsdWVzID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBhc3NlcnQoZWFnZXJWYWx1ZXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzO1xuICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IGdldFBhbmVsR3JvdXBFbGVtZW50KGdyb3VwSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICBhc3NlcnQoZ3JvdXBFbGVtZW50ICE9IG51bGwsIGBObyBncm91cCBmb3VuZCBmb3IgaWQgXCIke2dyb3VwSWR9XCJgKTtcbiAgICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cChncm91cElkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgYXNzZXJ0KGhhbmRsZXMpO1xuICAgIGNvbnN0IGNsZWFudXBGdW5jdGlvbnMgPSBoYW5kbGVzLm1hcChoYW5kbGUgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlSWQgPSBoYW5kbGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXCIpO1xuICAgICAgYXNzZXJ0KGhhbmRsZUlkKTtcbiAgICAgIGNvbnN0IFtpZEJlZm9yZSwgaWRBZnRlcl0gPSBnZXRSZXNpemVIYW5kbGVQYW5lbElkcyhncm91cElkLCBoYW5kbGVJZCwgcGFuZWxEYXRhQXJyYXksIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICAgIGlmIChpZEJlZm9yZSA9PSBudWxsIHx8IGlkQWZ0ZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBvbktleURvd24gPSBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFuZWxEYXRhQXJyYXkuZmluZEluZGV4KHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuaWQgPT09IGlkQmVmb3JlKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYW5lbERhdGEgPSBwYW5lbERhdGFBcnJheVtpbmRleF07XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHBhbmVsRGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGxheW91dFtpbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgICAgICAgICAgICBjb2xsYXBzaWJsZSxcbiAgICAgICAgICAgICAgICAgIG1pblNpemUgPSAwXG4gICAgICAgICAgICAgICAgfSA9IHBhbmVsRGF0YS5jb25zdHJhaW50cztcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSAhPSBudWxsICYmIGNvbGxhcHNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXh0TGF5b3V0ID0gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhOiBmdXp6eU51bWJlcnNFcXVhbChzaXplLCBjb2xsYXBzZWRTaXplKSA/IG1pblNpemUgLSBjb2xsYXBzZWRTaXplIDogY29sbGFwc2VkU2l6ZSAtIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpLFxuICAgICAgICAgICAgICAgICAgICBwaXZvdEluZGljZXM6IGRldGVybWluZVBpdm90SW5kaWNlcyhncm91cElkLCBoYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcImtleWJvYXJkXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKGxheW91dCAhPT0gbmV4dExheW91dCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRMYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBoYW5kbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBGdW5jdGlvbnMuZm9yRWFjaChjbGVhbnVwRnVuY3Rpb24gPT4gY2xlYW51cEZ1bmN0aW9uKCkpO1xuICAgIH07XG4gIH0sIFtwYW5lbEdyb3VwRWxlbWVudCwgY29tbWl0dGVkVmFsdWVzUmVmLCBlYWdlclZhbHVlc1JlZiwgZ3JvdXBJZCwgbGF5b3V0LCBwYW5lbERhdGFBcnJheSwgc2V0TGF5b3V0XSk7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsKGFycmF5QSwgYXJyYXlCKSB7XG4gIGlmIChhcnJheUEubGVuZ3RoICE9PSBhcnJheUIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGFycmF5QVtpbmRleF0gIT09IGFycmF5QltpbmRleF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzS2V5RG93bihldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCI7XG59XG5mdW5jdGlvbiBpc01vdXNlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcIm1vdXNlXCIpO1xufVxuZnVuY3Rpb24gaXNUb3VjaEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplRXZlbnRDdXJzb3JQb3NpdGlvbihkaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgcmV0dXJuIGlzSG9yaXpvbnRhbCA/IGV2ZW50LmNsaWVudFggOiBldmVudC5jbGllbnRZO1xuICB9IGVsc2UgaWYgKGlzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICBjb25zdCBmaXJzdFRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICBhc3NlcnQoZmlyc3RUb3VjaCk7XG4gICAgcmV0dXJuIGlzSG9yaXpvbnRhbCA/IGZpcnN0VG91Y2guc2NyZWVuWCA6IGZpcnN0VG91Y2guc2NyZWVuWTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgZXZlbnQgdHlwZSBcIiR7ZXZlbnQudHlwZX1cImApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURyYWdPZmZzZXRQZXJjZW50YWdlKGV2ZW50LCBkcmFnSGFuZGxlSWQsIGRpcmVjdGlvbiwgaW5pdGlhbERyYWdTdGF0ZSwgcGFuZWxHcm91cEVsZW1lbnQpIHtcbiAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgY29uc3QgaGFuZGxlRWxlbWVudCA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnQoZHJhZ0hhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gIGFzc2VydChoYW5kbGVFbGVtZW50KTtcbiAgY29uc3QgZ3JvdXBJZCA9IGhhbmRsZUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1ncm91cC1pZFwiKTtcbiAgYXNzZXJ0KGdyb3VwSWQpO1xuICBsZXQge1xuICAgIGluaXRpYWxDdXJzb3JQb3NpdGlvblxuICB9ID0gaW5pdGlhbERyYWdTdGF0ZTtcbiAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSBnZXRSZXNpemVFdmVudEN1cnNvclBvc2l0aW9uKGRpcmVjdGlvbiwgZXZlbnQpO1xuICBjb25zdCBncm91cEVsZW1lbnQgPSBnZXRQYW5lbEdyb3VwRWxlbWVudChncm91cElkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gIGFzc2VydChncm91cEVsZW1lbnQpO1xuICBjb25zdCBncm91cFJlY3QgPSBncm91cEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGdyb3VwU2l6ZUluUGl4ZWxzID0gaXNIb3Jpem9udGFsID8gZ3JvdXBSZWN0LndpZHRoIDogZ3JvdXBSZWN0LmhlaWdodDtcbiAgY29uc3Qgb2Zmc2V0UGl4ZWxzID0gY3Vyc29yUG9zaXRpb24gLSBpbml0aWFsQ3Vyc29yUG9zaXRpb247XG4gIGNvbnN0IG9mZnNldFBlcmNlbnRhZ2UgPSBvZmZzZXRQaXhlbHMgLyBncm91cFNpemVJblBpeGVscyAqIDEwMDtcbiAgcmV0dXJuIG9mZnNldFBlcmNlbnRhZ2U7XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L21vdmVtZW50WFxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGFQZXJjZW50YWdlKGV2ZW50LCBkcmFnSGFuZGxlSWQsIGRpcmVjdGlvbiwgaW5pdGlhbERyYWdTdGF0ZSwga2V5Ym9hcmRSZXNpemVCeSwgcGFuZWxHcm91cEVsZW1lbnQpIHtcbiAgaWYgKGlzS2V5RG93bihldmVudCkpIHtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBkZWx0YSA9IDEwMDtcbiAgICB9IGVsc2UgaWYgKGtleWJvYXJkUmVzaXplQnkgIT0gbnVsbCkge1xuICAgICAgZGVsdGEgPSBrZXlib2FyZFJlc2l6ZUJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWx0YSA9IDEwO1xuICAgIH1cbiAgICBsZXQgbW92ZW1lbnQgPSAwO1xuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gMCA6IGRlbHRhO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyAtZGVsdGEgOiAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gZGVsdGEgOiAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gMCA6IC1kZWx0YTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgIG1vdmVtZW50ID0gMTAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgIG1vdmVtZW50ID0gLTEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlbWVudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaW5pdGlhbERyYWdTdGF0ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGN1bGF0ZURyYWdPZmZzZXRQZXJjZW50YWdlKGV2ZW50LCBkcmFnSGFuZGxlSWQsIGRpcmVjdGlvbiwgaW5pdGlhbERyYWdTdGF0ZSwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICB9XG59XG5cbi8vIExheW91dCBzaG91bGQgYmUgcHJlLWNvbnZlcnRlZCBpbnRvIHBlcmNlbnRhZ2VzXG5mdW5jdGlvbiBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxzQXJyYXksIGxheW91dCwgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCkge1xuICBsYXlvdXQuZm9yRWFjaCgoc2l6ZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYW5lbERhdGEgPSBwYW5lbHNBcnJheVtpbmRleF07XG4gICAgYXNzZXJ0KHBhbmVsRGF0YSk7XG4gICAgY29uc3Qge1xuICAgICAgY2FsbGJhY2tzLFxuICAgICAgY29uc3RyYWludHMsXG4gICAgICBpZDogcGFuZWxJZFxuICAgIH0gPSBwYW5lbERhdGE7XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBjb2xsYXBzaWJsZVxuICAgIH0gPSBjb25zdHJhaW50cztcbiAgICBjb25zdCBsYXN0Tm90aWZpZWRTaXplID0gcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFtwYW5lbElkXTtcbiAgICBpZiAobGFzdE5vdGlmaWVkU2l6ZSA9PSBudWxsIHx8IHNpemUgIT09IGxhc3ROb3RpZmllZFNpemUpIHtcbiAgICAgIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBbcGFuZWxJZF0gPSBzaXplO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbkNvbGxhcHNlLFxuICAgICAgICBvbkV4cGFuZCxcbiAgICAgICAgb25SZXNpemVcbiAgICAgIH0gPSBjYWxsYmFja3M7XG4gICAgICBpZiAob25SZXNpemUpIHtcbiAgICAgICAgb25SZXNpemUoc2l6ZSwgbGFzdE5vdGlmaWVkU2l6ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY29sbGFwc2libGUgJiYgKG9uQ29sbGFwc2UgfHwgb25FeHBhbmQpKSB7XG4gICAgICAgIGlmIChvbkV4cGFuZCAmJiAobGFzdE5vdGlmaWVkU2l6ZSA9PSBudWxsIHx8IGxhc3ROb3RpZmllZFNpemUgPT09IGNvbGxhcHNlZFNpemUpICYmIHNpemUgIT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgICBvbkV4cGFuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNvbGxhcHNlICYmIChsYXN0Tm90aWZpZWRTaXplID09IG51bGwgfHwgbGFzdE5vdGlmaWVkU2l6ZSAhPT0gY29sbGFwc2VkU2l6ZSkgJiYgc2l6ZSA9PT0gY29sbGFwc2VkU2l6ZSkge1xuICAgICAgICAgIG9uQ29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVMYXlvdXRzKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChhW2luZGV4XSAhPSBiW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgMTAwIHJlcHJlc2VudGluZ1xuXG4vLyB0aGUgJSBvZiB0aGUgZ3JvdXAncyBvdmVyYWxsIHNwYWNlIHRoaXMgcGFuZWwgc2hvdWxkIG9jY3VweS5cbmZ1bmN0aW9uIGNvbXB1dGVQYW5lbEZsZXhCb3hTdHlsZSh7XG4gIGRlZmF1bHRTaXplLFxuICBkcmFnU3RhdGUsXG4gIGxheW91dCxcbiAgcGFuZWxEYXRhLFxuICBwYW5lbEluZGV4LFxuICBwcmVjaXNpb24gPSAzXG59KSB7XG4gIGNvbnN0IHNpemUgPSBsYXlvdXRbcGFuZWxJbmRleF07XG4gIGxldCBmbGV4R3JvdztcbiAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgIC8vIEluaXRpYWwgcmVuZGVyIChiZWZvcmUgcGFuZWxzIGhhdmUgcmVnaXN0ZXJlZCB0aGVtc2VsdmVzKVxuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgc2VydmVyIHJlbmRlcmluZywgZmFsbCBiYWNrIHRvIGRlZmF1bHQgc2l6ZSBpZiBwcm92aWRlZFxuICAgIGZsZXhHcm93ID0gZGVmYXVsdFNpemUgIT09IG51bGwgJiYgZGVmYXVsdFNpemUgIT09IHZvaWQgMCA/IGRlZmF1bHRTaXplIDogXCIxXCI7XG4gIH0gZWxzZSBpZiAocGFuZWxEYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogU2luZ2xlIHBhbmVsIGdyb3VwIHNob3VsZCBhbHdheXMgZmlsbCBmdWxsIHdpZHRoL2hlaWdodFxuICAgIGZsZXhHcm93ID0gXCIxXCI7XG4gIH0gZWxzZSB7XG4gICAgZmxleEdyb3cgPSBzaXplLnRvUHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmbGV4QmFzaXM6IDAsXG4gICAgZmxleEdyb3csXG4gICAgZmxleFNocmluazogMSxcbiAgICAvLyBXaXRob3V0IHRoaXMsIFBhbmVsIHNpemVzIG1heSBiZSB1bmludGVudGlvbmFsbHkgb3ZlcnJpZGRlbiBieSB0aGVpciBjb250ZW50XG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgLy8gRGlzYWJsZSBwb2ludGVyIGV2ZW50cyBpbnNpZGUgb2YgYSBwYW5lbCBkdXJpbmcgcmVzaXplXG4gICAgLy8gVGhpcyBhdm9pZCBlZGdlIGNhc2VzIGxpa2UgbmVzdGVkIGlmcmFtZXNcbiAgICBwb2ludGVyRXZlbnRzOiBkcmFnU3RhdGUgIT09IG51bGwgPyBcIm5vbmVcIiA6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5sZXQgY3VycmVudFN0YXRlID0gbnVsbDtcbmxldCBlbGVtZW50ID0gbnVsbDtcbmZ1bmN0aW9uIGdldEN1cnNvclN0eWxlKHN0YXRlKSB7XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgcmV0dXJuIFwiZXctcmVzaXplXCI7XG4gICAgY2FzZSBcImhvcml6b250YWwtbWF4XCI6XG4gICAgICByZXR1cm4gXCJ3LXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJob3Jpem9udGFsLW1pblwiOlxuICAgICAgcmV0dXJuIFwiZS1yZXNpemVcIjtcbiAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgIHJldHVybiBcIm5zLXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJ2ZXJ0aWNhbC1tYXhcIjpcbiAgICAgIHJldHVybiBcIm4tcmVzaXplXCI7XG4gICAgY2FzZSBcInZlcnRpY2FsLW1pblwiOlxuICAgICAgcmV0dXJuIFwicy1yZXNpemVcIjtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRHbG9iYWxDdXJzb3JTdHlsZSgpIHtcbiAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIGN1cnJlbnRTdGF0ZSA9IG51bGw7XG4gICAgZWxlbWVudCA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEdsb2JhbEN1cnNvclN0eWxlKHN0YXRlKSB7XG4gIGlmIChjdXJyZW50U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuICBjb25zdCBzdHlsZSA9IGdldEN1cnNvclN0eWxlKHN0YXRlKTtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbiAgZWxlbWVudC5pbm5lckhUTUwgPSBgKntjdXJzb3I6ICR7c3R5bGV9IWltcG9ydGFudDt9YDtcbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoY2FsbGJhY2ssIGR1cmF0aW9uTXMgPSAxMCkge1xuICBsZXQgdGltZW91dElkID0gbnVsbDtcbiAgbGV0IGNhbGxhYmxlID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAodGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9XG4gICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjYWxsYmFjayguLi5hcmdzKTtcbiAgICB9LCBkdXJhdGlvbk1zKTtcbiAgfTtcbiAgcmV0dXJuIGNhbGxhYmxlO1xufVxuXG4vLyBQYW5lbEdyb3VwIG1pZ2h0IGJlIHJlbmRlcmluZyBpbiBhIHNlcnZlci1zaWRlIGVudmlyb25tZW50IHdoZXJlIGxvY2FsU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlXG4vLyBvciBvbiBhIGJyb3dzZXIgd2l0aCBjb29raWVzL3N0b3JhZ2UgZGlzYWJsZWQuXG4vLyBJbiBlaXRoZXIgY2FzZSwgdGhpcyBmdW5jdGlvbiBhdm9pZHMgYWNjZXNzaW5nIGxvY2FsU3RvcmFnZSB1bnRpbCBuZWVkZWQsXG4vLyBhbmQgYXZvaWRzIHRocm93aW5nIHVzZXItdmlzaWJsZSBlcnJvcnMuXG5mdW5jdGlvbiBpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2Uoc3RvcmFnZU9iamVjdCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAvLyBCeXBhc3MgdGhpcyBjaGVjayBmb3IgZnV0dXJlIGNhbGxzXG4gICAgICBzdG9yYWdlT2JqZWN0LmdldEl0ZW0gPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICAgICAgfTtcbiAgICAgIHN0b3JhZ2VPYmplY3Quc2V0SXRlbSA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2NhbFN0b3JhZ2Ugbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50XCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICBzdG9yYWdlT2JqZWN0LmdldEl0ZW0gPSAoKSA9PiBudWxsO1xuICAgIHN0b3JhZ2VPYmplY3Quc2V0SXRlbSA9ICgpID0+IHt9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhbmVsR3JvdXBLZXkoYXV0b1NhdmVJZCkge1xuICByZXR1cm4gYHJlYWN0LXJlc2l6YWJsZS1wYW5lbHM6JHthdXRvU2F2ZUlkfWA7XG59XG5cbi8vIE5vdGUgdGhhdCBQYW5lbCBpZHMgbWlnaHQgYmUgdXNlci1wcm92aWRlZCAoc3RhYmxlKSBvciB1c2VJZCBnZW5lcmF0ZWQgKG5vbi1kZXRlcm1pbmlzdGljKVxuLy8gc28gdGhleSBzaG91bGQgbm90IGJlIHVzZWQgYXMgcGFydCBvZiB0aGUgc2VyaWFsaXphdGlvbiBrZXkuXG4vLyBVc2luZyB0aGUgbWluL21heCBzaXplIGF0dHJpYnV0ZXMgc2hvdWxkIHdvcmsgd2VsbCBlbm91Z2ggYXMgYSBiYWNrdXAuXG4vLyBQcmUtc29ydGluZyBieSBtaW5TaXplIGFsbG93cyByZW1lbWJlcmluZyBsYXlvdXRzIGV2ZW4gaWYgcGFuZWxzIGFyZSByZS1vcmRlcmVkL2RyYWdnZWQuXG5mdW5jdGlvbiBnZXRQYW5lbEtleShwYW5lbHMpIHtcbiAgcmV0dXJuIHBhbmVscy5tYXAocGFuZWwgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnN0cmFpbnRzLFxuICAgICAgaWQsXG4gICAgICBpZElzRnJvbVByb3BzLFxuICAgICAgb3JkZXJcbiAgICB9ID0gcGFuZWw7XG4gICAgaWYgKGlkSXNGcm9tUHJvcHMpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9yZGVyID8gYCR7b3JkZXJ9OiR7SlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpfWAgOiBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cyk7XG4gICAgfVxuICB9KS5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpLmpvaW4oXCIsXCIpO1xufVxuZnVuY3Rpb24gbG9hZFNlcmlhbGl6ZWRQYW5lbEdyb3VwU3RhdGUoYXV0b1NhdmVJZCwgc3RvcmFnZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHBhbmVsR3JvdXBLZXkgPSBnZXRQYW5lbEdyb3VwS2V5KGF1dG9TYXZlSWQpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzdG9yYWdlLmdldEl0ZW0ocGFuZWxHcm91cEtleSk7XG4gICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICBpZiAodHlwZW9mIHBhcnNlZCA9PT0gXCJvYmplY3RcIiAmJiBwYXJzZWQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2F2ZVBhbmVsR3JvdXBTdGF0ZShhdXRvU2F2ZUlkLCBwYW5lbHMsIHBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZSwgc2l6ZXMsIHN0b3JhZ2UpIHtcbiAgdmFyIF9sb2FkU2VyaWFsaXplZFBhbmVsRzI7XG4gIGNvbnN0IHBhbmVsR3JvdXBLZXkgPSBnZXRQYW5lbEdyb3VwS2V5KGF1dG9TYXZlSWQpO1xuICBjb25zdCBwYW5lbEtleSA9IGdldFBhbmVsS2V5KHBhbmVscyk7XG4gIGNvbnN0IHN0YXRlID0gKF9sb2FkU2VyaWFsaXplZFBhbmVsRzIgPSBsb2FkU2VyaWFsaXplZFBhbmVsR3JvdXBTdGF0ZShhdXRvU2F2ZUlkLCBzdG9yYWdlKSkgIT09IG51bGwgJiYgX2xvYWRTZXJpYWxpemVkUGFuZWxHMiAhPT0gdm9pZCAwID8gX2xvYWRTZXJpYWxpemVkUGFuZWxHMiA6IHt9O1xuICBzdGF0ZVtwYW5lbEtleV0gPSB7XG4gICAgZXhwYW5kVG9TaXplczogT2JqZWN0LmZyb21FbnRyaWVzKHBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZS5lbnRyaWVzKCkpLFxuICAgIGxheW91dDogc2l6ZXNcbiAgfTtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlLnNldEl0ZW0ocGFuZWxHcm91cEtleSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVBhbmVsQ29uc3RyYWludHMoe1xuICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gIHBhbmVsSWQsXG4gIHBhbmVsSW5kZXhcbn0pIHtcbiAge1xuICAgIGNvbnN0IHdhcm5pbmdzID0gW107XG4gICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsQ29uc3RyYWludHNBcnJheVtwYW5lbEluZGV4XTtcbiAgICBhc3NlcnQocGFuZWxDb25zdHJhaW50cyk7XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBjb2xsYXBzaWJsZSA9IGZhbHNlLFxuICAgICAgZGVmYXVsdFNpemUsXG4gICAgICBtYXhTaXplID0gMTAwLFxuICAgICAgbWluU2l6ZSA9IDBcbiAgICB9ID0gcGFuZWxDb25zdHJhaW50cztcbiAgICBpZiAobWluU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goYG1pbiBzaXplICgke21pblNpemV9JSkgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gbWF4IHNpemUgKCR7bWF4U2l6ZX0lKWApO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNpemUgIT0gbnVsbCkge1xuICAgICAgaWYgKGRlZmF1bHRTaXplIDwgMCkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKFwiZGVmYXVsdCBzaXplIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gICAgICB9IGVsc2UgaWYgKGRlZmF1bHRTaXplIDwgbWluU2l6ZSAmJiAoIWNvbGxhcHNpYmxlIHx8IGRlZmF1bHRTaXplICE9PSBjb2xsYXBzZWRTaXplKSkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKFwiZGVmYXVsdCBzaXplIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIG1pbiBzaXplXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRTaXplID4gMTAwKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goXCJkZWZhdWx0IHNpemUgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gMTAwXCIpO1xuICAgICAgfSBlbHNlIGlmIChkZWZhdWx0U2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgd2FybmluZ3MucHVzaChcImRlZmF1bHQgc2l6ZSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiBtYXggc2l6ZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbGxhcHNlZFNpemUgPiBtaW5TaXplKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKFwiY29sbGFwc2VkIHNpemUgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gbWluIHNpemVcIik7XG4gICAgfVxuICAgIGlmICh3YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBuYW1lID0gcGFuZWxJZCAhPSBudWxsID8gYFBhbmVsIFwiJHtwYW5lbElkfVwiYCA6IFwiUGFuZWxcIjtcbiAgICAgIGNvbnNvbGUud2FybihgJHtuYW1lfSBoYXMgYW4gaW52YWxpZCBjb25maWd1cmF0aW9uOlxcblxcbiR7d2FybmluZ3Muam9pbihcIlxcblwiKX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEFsbCB1bml0cyBtdXN0IGJlIGluIHBlcmNlbnRhZ2VzOyBwaXhlbCB2YWx1ZXMgc2hvdWxkIGJlIHByZS1jb252ZXJ0ZWRcbmZ1bmN0aW9uIHZhbGlkYXRlUGFuZWxHcm91cExheW91dCh7XG4gIGxheW91dDogcHJldkxheW91dCxcbiAgcGFuZWxDb25zdHJhaW50c1xufSkge1xuICBjb25zdCBuZXh0TGF5b3V0ID0gWy4uLnByZXZMYXlvdXRdO1xuICBjb25zdCBuZXh0TGF5b3V0VG90YWxTaXplID0gbmV4dExheW91dC5yZWR1Y2UoKGFjY3VtdWxhdGVkLCBjdXJyZW50KSA9PiBhY2N1bXVsYXRlZCArIGN1cnJlbnQsIDApO1xuXG4gIC8vIFZhbGlkYXRlIGxheW91dCBleHBlY3RhdGlvbnNcbiAgaWYgKG5leHRMYXlvdXQubGVuZ3RoICE9PSBwYW5lbENvbnN0cmFpbnRzLmxlbmd0aCkge1xuICAgIHRocm93IEVycm9yKGBJbnZhbGlkICR7cGFuZWxDb25zdHJhaW50cy5sZW5ndGh9IHBhbmVsIGxheW91dDogJHtuZXh0TGF5b3V0Lm1hcChzaXplID0+IGAke3NpemV9JWApLmpvaW4oXCIsIFwiKX1gKTtcbiAgfSBlbHNlIGlmICghZnV6enlOdW1iZXJzRXF1YWwobmV4dExheW91dFRvdGFsU2l6ZSwgMTAwKSkge1xuICAgIC8vIFRoaXMgaXMgbm90IGlkZWFsIHNvIHdlIHNob3VsZCB3YXJuIGFib3V0IGl0LCBidXQgaXQgbWF5IGJlIHJlY292ZXJhYmxlIGluIHNvbWUgY2FzZXNcbiAgICAvLyAoZXNwZWNpYWxseSBpZiB0aGUgYW1vdW50IGlzIHNtYWxsKVxuICAgIHtcbiAgICAgIGNvbnNvbGUud2FybihgV0FSTklORzogSW52YWxpZCBsYXlvdXQgdG90YWwgc2l6ZTogJHtuZXh0TGF5b3V0Lm1hcChzaXplID0+IGAke3NpemV9JWApLmpvaW4oXCIsIFwiKX0uIExheW91dCBub3JtYWxpemF0aW9uIHdpbGwgYmUgYXBwbGllZC5gKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCB1bnNhZmVTaXplID0gbmV4dExheW91dFtpbmRleF07XG4gICAgICBhc3NlcnQodW5zYWZlU2l6ZSAhPSBudWxsKTtcbiAgICAgIGNvbnN0IHNhZmVTaXplID0gMTAwIC8gbmV4dExheW91dFRvdGFsU2l6ZSAqIHVuc2FmZVNpemU7XG4gICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuICAgIH1cbiAgfVxuICBsZXQgcmVtYWluaW5nU2l6ZSA9IDA7XG5cbiAgLy8gRmlyc3QgcGFzczogVmFsaWRhdGUgdGhlIHByb3Bvc2VkIGxheW91dCBnaXZlbiBlYWNoIHBhbmVsJ3MgY29uc3RyYWludHNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgdW5zYWZlU2l6ZSA9IG5leHRMYXlvdXRbaW5kZXhdO1xuICAgIGFzc2VydCh1bnNhZmVTaXplICE9IG51bGwpO1xuICAgIGNvbnN0IHNhZmVTaXplID0gcmVzaXplUGFuZWwoe1xuICAgICAgcGFuZWxDb25zdHJhaW50cyxcbiAgICAgIHBhbmVsSW5kZXg6IGluZGV4LFxuICAgICAgc2l6ZTogdW5zYWZlU2l6ZVxuICAgIH0pO1xuICAgIGlmICh1bnNhZmVTaXplICE9IHNhZmVTaXplKSB7XG4gICAgICByZW1haW5pbmdTaXplICs9IHVuc2FmZVNpemUgLSBzYWZlU2l6ZTtcbiAgICAgIG5leHRMYXlvdXRbaW5kZXhdID0gc2FmZVNpemU7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlcmUgaXMgYWRkaXRpb25hbCwgbGVmdCBvdmVyIHNwYWNlLCBhc3NpZ24gaXQgdG8gYW55IHBhbmVsKHMpIHRoYXQgcGVybWl0cyBpdFxuICAvLyAoSXQncyBub3Qgd29ydGggdGFraW5nIG11bHRpcGxlIGFkZGl0aW9uYWwgcGFzc2VzIHRvIGV2ZW5seSBkaXN0cmlidXRlKVxuICBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsKHJlbWFpbmluZ1NpemUsIDApKSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBwcmV2U2l6ZSA9IG5leHRMYXlvdXRbaW5kZXhdO1xuICAgICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwpO1xuICAgICAgY29uc3QgdW5zYWZlU2l6ZSA9IHByZXZTaXplICsgcmVtYWluaW5nU2l6ZTtcbiAgICAgIGNvbnN0IHNhZmVTaXplID0gcmVzaXplUGFuZWwoe1xuICAgICAgICBwYW5lbENvbnN0cmFpbnRzLFxuICAgICAgICBwYW5lbEluZGV4OiBpbmRleCxcbiAgICAgICAgc2l6ZTogdW5zYWZlU2l6ZVxuICAgICAgfSk7XG4gICAgICBpZiAocHJldlNpemUgIT09IHNhZmVTaXplKSB7XG4gICAgICAgIHJlbWFpbmluZ1NpemUgLT0gc2FmZVNpemUgLSBwcmV2U2l6ZTtcbiAgICAgICAgbmV4dExheW91dFtpbmRleF0gPSBzYWZlU2l6ZTtcblxuICAgICAgICAvLyBPbmNlIHdlJ3ZlIHVzZWQgdXAgdGhlIHJlbWFpbmRlciwgYmFpbFxuICAgICAgICBpZiAoZnV6enlOdW1iZXJzRXF1YWwocmVtYWluaW5nU2l6ZSwgMCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dExheW91dDtcbn1cblxuY29uc3QgTE9DQUxfU1RPUkFHRV9ERUJPVU5DRV9JTlRFUlZBTCA9IDEwMDtcbmNvbnN0IGRlZmF1bHRTdG9yYWdlID0ge1xuICBnZXRJdGVtOiBuYW1lID0+IHtcbiAgICBpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2UoZGVmYXVsdFN0b3JhZ2UpO1xuICAgIHJldHVybiBkZWZhdWx0U3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICB9LFxuICBzZXRJdGVtOiAobmFtZSwgdmFsdWUpID0+IHtcbiAgICBpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2UoZGVmYXVsdFN0b3JhZ2UpO1xuICAgIGRlZmF1bHRTdG9yYWdlLnNldEl0ZW0obmFtZSwgdmFsdWUpO1xuICB9XG59O1xuY29uc3QgZGVib3VuY2VNYXAgPSB7fTtcbmZ1bmN0aW9uIFBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmKHtcbiAgYXV0b1NhdmVJZCA9IG51bGwsXG4gIGNoaWxkcmVuLFxuICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyA9IFwiXCIsXG4gIGRpcmVjdGlvbixcbiAgZm9yd2FyZGVkUmVmLFxuICBpZDogaWRGcm9tUHJvcHMgPSBudWxsLFxuICBvbkxheW91dCA9IG51bGwsXG4gIGtleWJvYXJkUmVzaXplQnkgPSBudWxsLFxuICBzdG9yYWdlID0gZGVmYXVsdFN0b3JhZ2UsXG4gIHN0eWxlOiBzdHlsZUZyb21Qcm9wcyxcbiAgdGFnTmFtZTogVHlwZSA9IFwiZGl2XCIsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgZ3JvdXBJZCA9IHVzZVVuaXF1ZUlkKGlkRnJvbVByb3BzKTtcbiAgY29uc3QgcGFuZWxHcm91cEVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtkcmFnU3RhdGUsIHNldERyYWdTdGF0ZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2xheW91dCwgc2V0TGF5b3V0XSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZiA9IHVzZVJlZih7fSk7XG4gIGNvbnN0IHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlUmVmID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gIGNvbnN0IHByZXZEZWx0YVJlZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgY29tbWl0dGVkVmFsdWVzUmVmID0gdXNlUmVmKHtcbiAgICBhdXRvU2F2ZUlkLFxuICAgIGRpcmVjdGlvbixcbiAgICBkcmFnU3RhdGUsXG4gICAgaWQ6IGdyb3VwSWQsXG4gICAga2V5Ym9hcmRSZXNpemVCeSxcbiAgICBvbkxheW91dCxcbiAgICBzdG9yYWdlXG4gIH0pO1xuICBjb25zdCBlYWdlclZhbHVlc1JlZiA9IHVzZVJlZih7XG4gICAgbGF5b3V0LFxuICAgIHBhbmVsRGF0YUFycmF5OiBbXSxcbiAgICBwYW5lbERhdGFBcnJheUNoYW5nZWQ6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBkZXZXYXJuaW5nc1JlZiA9IHVzZVJlZih7XG4gICAgZGlkTG9nSWRBbmRPcmRlcldhcm5pbmc6IGZhbHNlLFxuICAgIGRpZExvZ1BhbmVsQ29uc3RyYWludHNXYXJuaW5nOiBmYWxzZSxcbiAgICBwcmV2UGFuZWxJZHM6IFtdXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCkgPT4gKHtcbiAgICBnZXRJZDogKCkgPT4gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQuaWQsXG4gICAgZ2V0TGF5b3V0OiAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH0sXG4gICAgc2V0TGF5b3V0OiB1bnNhZmVMYXlvdXQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbkxheW91dFxuICAgICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHNhZmVMYXlvdXQgPSB2YWxpZGF0ZVBhbmVsR3JvdXBMYXlvdXQoe1xuICAgICAgICBsYXlvdXQ6IHVuc2FmZUxheW91dCxcbiAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpXG4gICAgICB9KTtcbiAgICAgIGlmICghYXJlRXF1YWwocHJldkxheW91dCwgc2FmZUxheW91dCkpIHtcbiAgICAgICAgc2V0TGF5b3V0KHNhZmVMYXlvdXQpO1xuICAgICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LmxheW91dCA9IHNhZmVMYXlvdXQ7XG4gICAgICAgIGlmIChvbkxheW91dCkge1xuICAgICAgICAgIG9uTGF5b3V0KHNhZmVMYXlvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbERhdGFBcnJheSwgc2FmZUxheW91dCwgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBbXSk7XG4gIHVzZVdpbmRvd1NwbGl0dGVyUGFuZWxHcm91cEJlaGF2aW9yKHtcbiAgICBjb21taXR0ZWRWYWx1ZXNSZWYsXG4gICAgZWFnZXJWYWx1ZXNSZWYsXG4gICAgZ3JvdXBJZCxcbiAgICBsYXlvdXQsXG4gICAgcGFuZWxEYXRhQXJyYXk6IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQucGFuZWxEYXRhQXJyYXksXG4gICAgc2V0TGF5b3V0LFxuICAgIHBhbmVsR3JvdXBFbGVtZW50OiBwYW5lbEdyb3VwRWxlbWVudFJlZi5jdXJyZW50XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG5cbiAgICAvLyBJZiB0aGlzIHBhbmVsIGhhcyBiZWVuIGNvbmZpZ3VyZWQgdG8gcGVyc2lzdCBzaXppbmcgaW5mb3JtYXRpb24sIHNhdmUgc2l6ZXMgdG8gbG9jYWwgc3RvcmFnZS5cbiAgICBpZiAoYXV0b1NhdmVJZCkge1xuICAgICAgaWYgKGxheW91dC5sZW5ndGggPT09IDAgfHwgbGF5b3V0Lmxlbmd0aCAhPT0gcGFuZWxEYXRhQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBkZWJvdW5jZWRTYXZlID0gZGVib3VuY2VNYXBbYXV0b1NhdmVJZF07XG5cbiAgICAgIC8vIExpbWl0IHRoZSBmcmVxdWVuY3kgb2YgbG9jYWxTdG9yYWdlIHVwZGF0ZXMuXG4gICAgICBpZiAoZGVib3VuY2VkU2F2ZSA9PSBudWxsKSB7XG4gICAgICAgIGRlYm91bmNlZFNhdmUgPSBkZWJvdW5jZShzYXZlUGFuZWxHcm91cFN0YXRlLCBMT0NBTF9TVE9SQUdFX0RFQk9VTkNFX0lOVEVSVkFMKTtcbiAgICAgICAgZGVib3VuY2VNYXBbYXV0b1NhdmVJZF0gPSBkZWJvdW5jZWRTYXZlO1xuICAgICAgfVxuXG4gICAgICAvLyBDbG9uZSBtdXRhYmxlIGRhdGEgYmVmb3JlIHBhc3NpbmcgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbixcbiAgICAgIC8vIGVsc2Ugd2UgcnVuIHRoZSByaXNrIG9mIHNhdmluZyBhbiBpbmNvcnJlY3QgY29tYmluYXRpb24gb2YgbXV0YWJsZSBhbmQgaW1tdXRhYmxlIHZhbHVlcyB0byBzdGF0ZS5cbiAgICAgIGNvbnN0IGNsb25lZFBhbmVsRGF0YUFycmF5ID0gWy4uLnBhbmVsRGF0YUFycmF5XTtcbiAgICAgIGNvbnN0IGNsb25lZFBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZSA9IG5ldyBNYXAocGFuZWxTaXplQmVmb3JlQ29sbGFwc2VSZWYuY3VycmVudCk7XG4gICAgICBkZWJvdW5jZWRTYXZlKGF1dG9TYXZlSWQsIGNsb25lZFBhbmVsRGF0YUFycmF5LCBjbG9uZWRQYW5lbFNpemVzQmVmb3JlQ29sbGFwc2UsIGxheW91dCwgc3RvcmFnZSk7XG4gICAgfVxuICB9LCBbYXV0b1NhdmVJZCwgbGF5b3V0LCBzdG9yYWdlXSk7XG5cbiAgLy8gREVWIHdhcm5pbmdzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYW5lbERhdGFBcnJheVxuICAgICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nLFxuICAgICAgICBkaWRMb2dQYW5lbENvbnN0cmFpbnRzV2FybmluZyxcbiAgICAgICAgcHJldlBhbmVsSWRzXG4gICAgICB9ID0gZGV2V2FybmluZ3NSZWYuY3VycmVudDtcbiAgICAgIGlmICghZGlkTG9nSWRBbmRPcmRlcldhcm5pbmcpIHtcbiAgICAgICAgY29uc3QgcGFuZWxJZHMgPSBwYW5lbERhdGFBcnJheS5tYXAoKHtcbiAgICAgICAgICBpZFxuICAgICAgICB9KSA9PiBpZCk7XG4gICAgICAgIGRldldhcm5pbmdzUmVmLmN1cnJlbnQucHJldlBhbmVsSWRzID0gcGFuZWxJZHM7XG4gICAgICAgIGNvbnN0IHBhbmVsc0hhdmVDaGFuZ2VkID0gcHJldlBhbmVsSWRzLmxlbmd0aCA+IDAgJiYgIWFyZUVxdWFsKHByZXZQYW5lbElkcywgcGFuZWxJZHMpO1xuICAgICAgICBpZiAocGFuZWxzSGF2ZUNoYW5nZWQpIHtcbiAgICAgICAgICBpZiAocGFuZWxEYXRhQXJyYXkuZmluZCgoe1xuICAgICAgICAgICAgaWRJc0Zyb21Qcm9wcyxcbiAgICAgICAgICAgIG9yZGVyXG4gICAgICAgICAgfSkgPT4gIWlkSXNGcm9tUHJvcHMgfHwgb3JkZXIgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIGRldldhcm5pbmdzUmVmLmN1cnJlbnQuZGlkTG9nSWRBbmRPcmRlcldhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBQYW5lbCBpZCBhbmQgb3JkZXIgcHJvcHMgcmVjb21tZW5kZWQgd2hlbiBwYW5lbHMgYXJlIGR5bmFtaWNhbGx5IHJlbmRlcmVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWRpZExvZ1BhbmVsQ29uc3RyYWludHNXYXJuaW5nKSB7XG4gICAgICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHMgPSBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cyk7XG4gICAgICAgIGZvciAobGV0IHBhbmVsSW5kZXggPSAwOyBwYW5lbEluZGV4IDwgcGFuZWxDb25zdHJhaW50cy5sZW5ndGg7IHBhbmVsSW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IHBhbmVsRGF0YSA9IHBhbmVsRGF0YUFycmF5W3BhbmVsSW5kZXhdO1xuICAgICAgICAgIGFzc2VydChwYW5lbERhdGEpO1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0ZVBhbmVsQ29uc3RyYWludHMoe1xuICAgICAgICAgICAgcGFuZWxDb25zdHJhaW50cyxcbiAgICAgICAgICAgIHBhbmVsSWQ6IHBhbmVsRGF0YS5pZCxcbiAgICAgICAgICAgIHBhbmVsSW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgIGRldldhcm5pbmdzUmVmLmN1cnJlbnQuZGlkTG9nUGFuZWxDb25zdHJhaW50c1dhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IGNvbGxhcHNlUGFuZWwgPSB1c2VDYWxsYmFjayhwYW5lbERhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTGF5b3V0XG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dDogcHJldkxheW91dCxcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKHBhbmVsRGF0YS5jb25zdHJhaW50cy5jb2xsYXBzaWJsZSkge1xuICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50c0FycmF5ID0gcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgICAgcGFuZWxTaXplLFxuICAgICAgICBwaXZvdEluZGljZXNcbiAgICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgcHJldkxheW91dCk7XG4gICAgICBhc3NlcnQocGFuZWxTaXplICE9IG51bGwpO1xuICAgICAgaWYgKHBhbmVsU2l6ZSAhPT0gY29sbGFwc2VkU2l6ZSkge1xuICAgICAgICAvLyBTdG9yZSBzaXplIGJlZm9yZSBjb2xsYXBzZTtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgc2l6ZSB0aGF0IGdldHMgcmVzdG9yZWQgaWYgdGhlIGV4cGFuZCgpIEFQSSBpcyB1c2VkLlxuICAgICAgICBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZi5jdXJyZW50LnNldChwYW5lbERhdGEuaWQsIHBhbmVsU2l6ZSk7XG4gICAgICAgIGNvbnN0IGlzTGFzdFBhbmVsID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpID09PSBwYW5lbERhdGFBcnJheS5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGlzTGFzdFBhbmVsID8gcGFuZWxTaXplIC0gY29sbGFwc2VkU2l6ZSA6IGNvbGxhcHNlZFNpemUgLSBwYW5lbFNpemU7XG4gICAgICAgIGNvbnN0IG5leHRMYXlvdXQgPSBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgICAgIHBpdm90SW5kaWNlcyxcbiAgICAgICAgICB0cmlnZ2VyOiBcImltcGVyYXRpdmUtYXBpXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY29tcGFyZUxheW91dHMocHJldkxheW91dCwgbmV4dExheW91dCkpIHtcbiAgICAgICAgICBzZXRMYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgICAgZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5sYXlvdXQgPSBuZXh0TGF5b3V0O1xuICAgICAgICAgIGlmIChvbkxheW91dCkge1xuICAgICAgICAgICAgb25MYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbERhdGFBcnJheSwgbmV4dExheW91dCwgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIEV4dGVybmFsIEFQSXMgYXJlIHNhZmUgdG8gbWVtb2l6ZSB2aWEgY29tbWl0dGVkIHZhbHVlcyByZWZcbiAgY29uc3QgZXhwYW5kUGFuZWwgPSB1c2VDYWxsYmFjayhwYW5lbERhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTGF5b3V0XG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dDogcHJldkxheW91dCxcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKHBhbmVsRGF0YS5jb25zdHJhaW50cy5jb2xsYXBzaWJsZSkge1xuICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50c0FycmF5ID0gcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgICAgcGFuZWxTaXplLFxuICAgICAgICBtaW5TaXplID0gMCxcbiAgICAgICAgcGl2b3RJbmRpY2VzXG4gICAgICB9ID0gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIHByZXZMYXlvdXQpO1xuICAgICAgaWYgKHBhbmVsU2l6ZSA9PT0gY29sbGFwc2VkU2l6ZSkge1xuICAgICAgICAvLyBSZXN0b3JlIHRoaXMgcGFuZWwgdG8gdGhlIHNpemUgaXQgd2FzIGJlZm9yZSBpdCB3YXMgY29sbGFwc2VkLCBpZiBwb3NzaWJsZS5cbiAgICAgICAgY29uc3QgcHJldlBhbmVsU2l6ZSA9IHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlUmVmLmN1cnJlbnQuZ2V0KHBhbmVsRGF0YS5pZCk7XG4gICAgICAgIGNvbnN0IGJhc2VTaXplID0gcHJldlBhbmVsU2l6ZSAhPSBudWxsICYmIHByZXZQYW5lbFNpemUgPj0gbWluU2l6ZSA/IHByZXZQYW5lbFNpemUgOiBtaW5TaXplO1xuICAgICAgICBjb25zdCBpc0xhc3RQYW5lbCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKSA9PT0gcGFuZWxEYXRhQXJyYXkubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBpc0xhc3RQYW5lbCA/IHBhbmVsU2l6ZSAtIGJhc2VTaXplIDogYmFzZVNpemUgLSBwYW5lbFNpemU7XG4gICAgICAgIGNvbnN0IG5leHRMYXlvdXQgPSBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgICAgIHBpdm90SW5kaWNlcyxcbiAgICAgICAgICB0cmlnZ2VyOiBcImltcGVyYXRpdmUtYXBpXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY29tcGFyZUxheW91dHMocHJldkxheW91dCwgbmV4dExheW91dCkpIHtcbiAgICAgICAgICBzZXRMYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgICAgZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5sYXlvdXQgPSBuZXh0TGF5b3V0O1xuICAgICAgICAgIGlmIChvbkxheW91dCkge1xuICAgICAgICAgICAgb25MYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbERhdGFBcnJheSwgbmV4dExheW91dCwgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIEV4dGVybmFsIEFQSXMgYXJlIHNhZmUgdG8gbWVtb2l6ZSB2aWEgY29tbWl0dGVkIHZhbHVlcyByZWZcbiAgY29uc3QgZ2V0UGFuZWxTaXplID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsU2l6ZVxuICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgbGF5b3V0KTtcbiAgICBhc3NlcnQocGFuZWxTaXplICE9IG51bGwpO1xuICAgIHJldHVybiBwYW5lbFNpemU7XG4gIH0sIFtdKTtcblxuICAvLyBUaGlzIEFQSSBzaG91bGQgbmV2ZXIgcmVhZCBmcm9tIGNvbW1pdHRlZFZhbHVlc1JlZlxuICBjb25zdCBnZXRQYW5lbFN0eWxlID0gdXNlQ2FsbGJhY2soKHBhbmVsRGF0YSwgZGVmYXVsdFNpemUpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHBhbmVsSW5kZXggPSBmaW5kUGFuZWxEYXRhSW5kZXgocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSk7XG4gICAgcmV0dXJuIGNvbXB1dGVQYW5lbEZsZXhCb3hTdHlsZSh7XG4gICAgICBkZWZhdWx0U2l6ZSxcbiAgICAgIGRyYWdTdGF0ZSxcbiAgICAgIGxheW91dCxcbiAgICAgIHBhbmVsRGF0YTogcGFuZWxEYXRhQXJyYXksXG4gICAgICBwYW5lbEluZGV4XG4gICAgfSk7XG4gIH0sIFtkcmFnU3RhdGUsIGxheW91dF0pO1xuXG4gIC8vIEV4dGVybmFsIEFQSXMgYXJlIHNhZmUgdG8gbWVtb2l6ZSB2aWEgY29tbWl0dGVkIHZhbHVlcyByZWZcbiAgY29uc3QgaXNQYW5lbENvbGxhcHNlZCA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgIGNvbGxhcHNpYmxlLFxuICAgICAgcGFuZWxTaXplXG4gICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBsYXlvdXQpO1xuICAgIHJldHVybiBjb2xsYXBzaWJsZSA9PT0gdHJ1ZSAmJiBwYW5lbFNpemUgPT09IGNvbGxhcHNlZFNpemU7XG4gIH0sIFtdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IGlzUGFuZWxFeHBhbmRlZCA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgIGNvbGxhcHNpYmxlLFxuICAgICAgcGFuZWxTaXplXG4gICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBsYXlvdXQpO1xuICAgIGFzc2VydChwYW5lbFNpemUgIT0gbnVsbCk7XG4gICAgcmV0dXJuICFjb2xsYXBzaWJsZSB8fCBwYW5lbFNpemUgPiBjb2xsYXBzZWRTaXplO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZ2lzdGVyUGFuZWwgPSB1c2VDYWxsYmFjayhwYW5lbERhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgcGFuZWxEYXRhQXJyYXkucHVzaChwYW5lbERhdGEpO1xuICAgIHBhbmVsRGF0YUFycmF5LnNvcnQoKHBhbmVsQSwgcGFuZWxCKSA9PiB7XG4gICAgICBjb25zdCBvcmRlckEgPSBwYW5lbEEub3JkZXI7XG4gICAgICBjb25zdCBvcmRlckIgPSBwYW5lbEIub3JkZXI7XG4gICAgICBpZiAob3JkZXJBID09IG51bGwgJiYgb3JkZXJCID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKG9yZGVyQSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAob3JkZXJCID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3JkZXJBIC0gb3JkZXJCO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQucGFuZWxEYXRhQXJyYXlDaGFuZ2VkID0gdHJ1ZTtcbiAgfSwgW10pO1xuICBjb25zdCByZWdpc3RlclJlc2l6ZUhhbmRsZSA9IHVzZUNhbGxiYWNrKGRyYWdIYW5kbGVJZCA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlc2l6ZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBwYW5lbEdyb3VwRWxlbWVudCA9IHBhbmVsR3JvdXBFbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIXBhbmVsR3JvdXBFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIGRyYWdTdGF0ZSxcbiAgICAgICAgaWQ6IGdyb3VwSWQsXG4gICAgICAgIGtleWJvYXJkUmVzaXplQnksXG4gICAgICAgIG9uTGF5b3V0XG4gICAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dDogcHJldkxheW91dCxcbiAgICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbml0aWFsTGF5b3V0XG4gICAgICB9ID0gZHJhZ1N0YXRlICE9PSBudWxsICYmIGRyYWdTdGF0ZSAhPT0gdm9pZCAwID8gZHJhZ1N0YXRlIDoge307XG4gICAgICBjb25zdCBwaXZvdEluZGljZXMgPSBkZXRlcm1pbmVQaXZvdEluZGljZXMoZ3JvdXBJZCwgZHJhZ0hhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgICBsZXQgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YVBlcmNlbnRhZ2UoZXZlbnQsIGRyYWdIYW5kbGVJZCwgZGlyZWN0aW9uLCBkcmFnU3RhdGUsIGtleWJvYXJkUmVzaXplQnksIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFN1cHBvcnQgUlRMIGxheW91dHNcbiAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gICAgICBpZiAoZG9jdW1lbnQuZGlyID09PSBcInJ0bFwiICYmIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHMgPSBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cyk7XG4gICAgICBjb25zdCBuZXh0TGF5b3V0ID0gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gICAgICAgIGRlbHRhLFxuICAgICAgICBsYXlvdXQ6IGluaXRpYWxMYXlvdXQgIT09IG51bGwgJiYgaW5pdGlhbExheW91dCAhPT0gdm9pZCAwID8gaW5pdGlhbExheW91dCA6IHByZXZMYXlvdXQsXG4gICAgICAgIHBhbmVsQ29uc3RyYWludHMsXG4gICAgICAgIHBpdm90SW5kaWNlcyxcbiAgICAgICAgdHJpZ2dlcjogaXNLZXlEb3duKGV2ZW50KSA/IFwia2V5Ym9hcmRcIiA6IFwibW91c2Utb3ItdG91Y2hcIlxuICAgICAgfSk7XG4gICAgICBjb25zdCBsYXlvdXRDaGFuZ2VkID0gIWNvbXBhcmVMYXlvdXRzKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpO1xuXG4gICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgY3Vyc29yIGZvciBsYXlvdXQgY2hhbmdlcyB0cmlnZ2VyZWQgYnkgdG91Y2gvbW91c2UgZXZlbnRzIChub3Qga2V5Ym9hcmQpXG4gICAgICAvLyBVcGRhdGUgdGhlIGN1cnNvciBldmVuIGlmIHRoZSBsYXlvdXQgaGFzbid0IGNoYW5nZWQgKHdlIG1heSBuZWVkIHRvIHNob3cgYW4gaW52YWxpZCBjdXJzb3Igc3RhdGUpXG4gICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSB8fCBpc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIC8vIFdhdGNoIGZvciBtdWx0aXBsZSBzdWJzZXF1ZW50IGRlbHRhczsgdGhpcyBtaWdodCBvY2N1ciBmb3IgdGlueSBjdXJzb3IgbW92ZW1lbnRzLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIFBhbmVsIHNpemVzIG1pZ2h0IG5vdCBjaGFuZ2XigJNcbiAgICAgICAgLy8gYnV0IHVwZGF0aW5nIGN1cnNvciBpbiB0aGlzIHNjZW5hcmlvIHdvdWxkIGNhdXNlIGEgZmxpY2tlci5cbiAgICAgICAgaWYgKHByZXZEZWx0YVJlZi5jdXJyZW50ICE9IGRlbHRhKSB7XG4gICAgICAgICAgcHJldkRlbHRhUmVmLmN1cnJlbnQgPSBkZWx0YTtcbiAgICAgICAgICBpZiAoIWxheW91dENoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwb2ludGVyIGhhcyBtb3ZlZCB0b28gZmFyIHRvIHJlc2l6ZSB0aGUgcGFuZWwgYW55IGZ1cnRoZXIsXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGN1cnNvciBzdHlsZSBmb3IgYSB2aXN1YWwgY2x1ZS5cbiAgICAgICAgICAgIC8vIFRoaXMgbWltaWNzIFZTIENvZGUgYmVoYXZpb3IuXG5cbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgc2V0R2xvYmFsQ3Vyc29yU3R5bGUoZGVsdGEgPCAwID8gXCJob3Jpem9udGFsLW1pblwiIDogXCJob3Jpem9udGFsLW1heFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldEdsb2JhbEN1cnNvclN0eWxlKGRlbHRhIDwgMCA/IFwidmVydGljYWwtbWluXCIgOiBcInZlcnRpY2FsLW1heFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGN1cnNvciBzdHlsZSB0byB0aGUgdGhlIG5vcm1hbCByZXNpemUgY3Vyc29yLlxuICAgICAgICAgICAgc2V0R2xvYmFsQ3Vyc29yU3R5bGUoaXNIb3Jpem9udGFsID8gXCJob3Jpem9udGFsXCIgOiBcInZlcnRpY2FsXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxheW91dENoYW5nZWQpIHtcbiAgICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LmxheW91dCA9IG5leHRMYXlvdXQ7XG4gICAgICAgIGlmIChvbkxheW91dCkge1xuICAgICAgICAgIG9uTGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbERhdGFBcnJheSwgbmV4dExheW91dCwgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gRXh0ZXJuYWwgQVBJcyBhcmUgc2FmZSB0byBtZW1vaXplIHZpYSBjb21taXR0ZWQgdmFsdWVzIHJlZlxuICBjb25zdCByZXNpemVQYW5lbCA9IHVzZUNhbGxiYWNrKChwYW5lbERhdGEsIHVuc2FmZVBhbmVsU2l6ZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTGF5b3V0XG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dDogcHJldkxheW91dCxcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcGFuZWxDb25zdHJhaW50c0FycmF5ID0gcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsU2l6ZSxcbiAgICAgIHBpdm90SW5kaWNlc1xuICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgcHJldkxheW91dCk7XG4gICAgYXNzZXJ0KHBhbmVsU2l6ZSAhPSBudWxsKTtcbiAgICBjb25zdCBpc0xhc3RQYW5lbCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKSA9PT0gcGFuZWxEYXRhQXJyYXkubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBkZWx0YSA9IGlzTGFzdFBhbmVsID8gcGFuZWxTaXplIC0gdW5zYWZlUGFuZWxTaXplIDogdW5zYWZlUGFuZWxTaXplIC0gcGFuZWxTaXplO1xuICAgIGNvbnN0IG5leHRMYXlvdXQgPSBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgICAgIGRlbHRhLFxuICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgcGl2b3RJbmRpY2VzLFxuICAgICAgdHJpZ2dlcjogXCJpbXBlcmF0aXZlLWFwaVwiXG4gICAgfSk7XG4gICAgaWYgKCFjb21wYXJlTGF5b3V0cyhwcmV2TGF5b3V0LCBuZXh0TGF5b3V0KSkge1xuICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5sYXlvdXQgPSBuZXh0TGF5b3V0O1xuICAgICAgaWYgKG9uTGF5b3V0KSB7XG4gICAgICAgIG9uTGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgfVxuICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsRGF0YUFycmF5LCBuZXh0TGF5b3V0LCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCByZWV2YWx1YXRlUGFuZWxDb25zdHJhaW50cyA9IHVzZUNhbGxiYWNrKChwYW5lbERhdGEsIHByZXZDb25zdHJhaW50cykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dCxcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZTogcHJldkNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgY29sbGFwc2libGU6IHByZXZDb2xsYXBzaWJsZSxcbiAgICAgIGRlZmF1bHRTaXplOiBwcmV2RGVmYXVsdFNpemUsXG4gICAgICBtYXhTaXplOiBwcmV2TWF4U2l6ZSA9IDEwMCxcbiAgICAgIG1pblNpemU6IHByZXZNaW5TaXplID0gMFxuICAgIH0gPSBwcmV2Q29uc3RyYWludHM7XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZTogbmV4dENvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgY29sbGFwc2libGU6IG5leHRDb2xsYXBzaWJsZSxcbiAgICAgIGRlZmF1bHRTaXplOiBuZXh0RGVmYXVsdFNpemUsXG4gICAgICBtYXhTaXplOiBuZXh0TWF4U2l6ZSA9IDEwMCxcbiAgICAgIG1pblNpemU6IG5leHRNaW5TaXplID0gMFxuICAgIH0gPSBwYW5lbERhdGEuY29uc3RyYWludHM7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxTaXplOiBwcmV2UGFuZWxTaXplXG4gICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBsYXlvdXQpO1xuICAgIGFzc2VydChwcmV2UGFuZWxTaXplICE9IG51bGwpO1xuICAgIGlmIChwcmV2Q29sbGFwc2libGUgJiYgbmV4dENvbGxhcHNpYmxlICYmIHByZXZDb2xsYXBzZWRTaXplICE9PSBuZXh0Q29sbGFwc2VkU2l6ZSAmJiBwcmV2UGFuZWxTaXplID09PSBwcmV2Q29sbGFwc2VkU2l6ZSkge1xuICAgICAgcmVzaXplUGFuZWwocGFuZWxEYXRhLCBuZXh0Q29sbGFwc2VkU2l6ZSk7XG4gICAgfSBlbHNlIGlmIChwcmV2UGFuZWxTaXplIDwgbmV4dE1pblNpemUpIHtcbiAgICAgIHJlc2l6ZVBhbmVsKHBhbmVsRGF0YSwgbmV4dE1pblNpemUpO1xuICAgIH0gZWxzZSBpZiAocHJldlBhbmVsU2l6ZSA+IG5leHRNYXhTaXplKSB7XG4gICAgICByZXNpemVQYW5lbChwYW5lbERhdGEsIG5leHRNYXhTaXplKTtcbiAgICB9XG4gIH0sIFtyZXNpemVQYW5lbF0pO1xuICBjb25zdCBzdGFydERyYWdnaW5nID0gdXNlQ2FsbGJhY2soKGRyYWdIYW5kbGVJZCwgZXZlbnQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkaXJlY3Rpb25cbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFwYW5lbEdyb3VwRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZUVsZW1lbnQgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50KGRyYWdIYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnRSZWYuY3VycmVudCk7XG4gICAgYXNzZXJ0KGhhbmRsZUVsZW1lbnQpO1xuICAgIGNvbnN0IGluaXRpYWxDdXJzb3JQb3NpdGlvbiA9IGdldFJlc2l6ZUV2ZW50Q3Vyc29yUG9zaXRpb24oZGlyZWN0aW9uLCBldmVudCk7XG4gICAgc2V0RHJhZ1N0YXRlKHtcbiAgICAgIGRyYWdIYW5kbGVJZCxcbiAgICAgIGRyYWdIYW5kbGVSZWN0OiBoYW5kbGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgaW5pdGlhbEN1cnNvclBvc2l0aW9uLFxuICAgICAgaW5pdGlhbExheW91dDogbGF5b3V0XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc3RvcERyYWdnaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJlc2V0R2xvYmFsQ3Vyc29yU3R5bGUoKTtcbiAgICBzZXREcmFnU3RhdGUobnVsbCk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlclBhbmVsID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGluZGV4ID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBwYW5lbERhdGFBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAvLyBUUklDS1lcbiAgICAgIC8vIFdoZW4gYSBwYW5lbCBpcyByZW1vdmVkIGZyb20gdGhlIGdyb3VwLCB3ZSBzaG91bGQgZGVsZXRlIHRoZSBtb3N0IHJlY2VudCBwcmV2LXNpemUgZW50cnkgZm9yIGl0LlxuICAgICAgLy8gSWYgd2UgZG9uJ3QgZG8gdGhpcywgdGhlbiBhIGNvbmRpdGlvbmFsbHkgcmVuZGVyZWQgcGFuZWwgbWlnaHQgbm90IGNhbGwgb25SZXNpemUgd2hlbiBpdCdzIHJlLW1vdW50ZWQuXG4gICAgICAvLyBTdHJpY3QgZWZmZWN0cyBtb2RlIG1ha2VzIHRoaXMgdHJpY2t5IHRob3VnaCBiZWNhdXNlIGFsbCBwYW5lbHMgd2lsbCBiZSByZWdpc3RlcmVkLCB1bnJlZ2lzdGVyZWQsIHRoZW4gcmUtcmVnaXN0ZXJlZCBvbiBtb3VudC5cbiAgICAgIGRlbGV0ZSBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnRbcGFuZWxEYXRhLmlkXTtcbiAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQucGFuZWxEYXRhQXJyYXlDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjb2xsYXBzZVBhbmVsLFxuICAgIGRpcmVjdGlvbixcbiAgICBkcmFnU3RhdGUsXG4gICAgZXhwYW5kUGFuZWwsXG4gICAgZ2V0UGFuZWxTaXplLFxuICAgIGdldFBhbmVsU3R5bGUsXG4gICAgZ3JvdXBJZCxcbiAgICBpc1BhbmVsQ29sbGFwc2VkLFxuICAgIGlzUGFuZWxFeHBhbmRlZCxcbiAgICByZWV2YWx1YXRlUGFuZWxDb25zdHJhaW50cyxcbiAgICByZWdpc3RlclBhbmVsLFxuICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlLFxuICAgIHJlc2l6ZVBhbmVsLFxuICAgIHN0YXJ0RHJhZ2dpbmcsXG4gICAgc3RvcERyYWdnaW5nLFxuICAgIHVucmVnaXN0ZXJQYW5lbCxcbiAgICBwYW5lbEdyb3VwRWxlbWVudDogcGFuZWxHcm91cEVsZW1lbnRSZWYuY3VycmVudFxuICB9KSwgW2NvbGxhcHNlUGFuZWwsIGRyYWdTdGF0ZSwgZGlyZWN0aW9uLCBleHBhbmRQYW5lbCwgZ2V0UGFuZWxTaXplLCBnZXRQYW5lbFN0eWxlLCBncm91cElkLCBpc1BhbmVsQ29sbGFwc2VkLCBpc1BhbmVsRXhwYW5kZWQsIHJlZXZhbHVhdGVQYW5lbENvbnN0cmFpbnRzLCByZWdpc3RlclBhbmVsLCByZWdpc3RlclJlc2l6ZUhhbmRsZSwgcmVzaXplUGFuZWwsIHN0YXJ0RHJhZ2dpbmcsIHN0b3BEcmFnZ2luZywgdW5yZWdpc3RlclBhbmVsXSk7XG4gIGNvbnN0IHN0eWxlID0ge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGZsZXhEaXJlY3Rpb246IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcInJvd1wiIDogXCJjb2x1bW5cIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIlxuICB9O1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChQYW5lbEdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIGNyZWF0ZUVsZW1lbnQoVHlwZSwge1xuICAgIC4uLnJlc3QsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIHJlZjogcGFuZWxHcm91cEVsZW1lbnRSZWYsXG4gICAgLy8gQ1NTIHNlbGVjdG9yc1xuICAgIFwiZGF0YS1wYW5lbC1ncm91cFwiOiBcIlwiLFxuICAgIFwiZGF0YS1wYW5lbC1ncm91cC1kaXJlY3Rpb25cIjogZGlyZWN0aW9uLFxuICAgIFwiZGF0YS1wYW5lbC1ncm91cC1pZFwiOiBncm91cElkXG4gIH0pKTtcbn1cbmNvbnN0IFBhbmVsR3JvdXAgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiBjcmVhdGVFbGVtZW50KFBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmLCB7XG4gIC4uLnByb3BzLFxuICBmb3J3YXJkZWRSZWY6IHJlZlxufSkpO1xuUGFuZWxHcm91cFdpdGhGb3J3YXJkZWRSZWYuZGlzcGxheU5hbWUgPSBcIlBhbmVsR3JvdXBcIjtcblBhbmVsR3JvdXAuZGlzcGxheU5hbWUgPSBcImZvcndhcmRSZWYoUGFuZWxHcm91cClcIjtcbmZ1bmN0aW9uIGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKSB7XG4gIHJldHVybiBwYW5lbERhdGFBcnJheS5maW5kSW5kZXgocHJldlBhbmVsRGF0YSA9PiBwcmV2UGFuZWxEYXRhID09PSBwYW5lbERhdGEgfHwgcHJldlBhbmVsRGF0YS5pZCA9PT0gcGFuZWxEYXRhLmlkKTtcbn1cbmZ1bmN0aW9uIHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBsYXlvdXQpIHtcbiAgY29uc3QgcGFuZWxJbmRleCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKTtcbiAgY29uc3QgaXNMYXN0UGFuZWwgPSBwYW5lbEluZGV4ID09PSBwYW5lbERhdGFBcnJheS5sZW5ndGggLSAxO1xuICBjb25zdCBwaXZvdEluZGljZXMgPSBpc0xhc3RQYW5lbCA/IFtwYW5lbEluZGV4IC0gMSwgcGFuZWxJbmRleF0gOiBbcGFuZWxJbmRleCwgcGFuZWxJbmRleCArIDFdO1xuICBjb25zdCBwYW5lbFNpemUgPSBsYXlvdXRbcGFuZWxJbmRleF07XG4gIHJldHVybiB7XG4gICAgLi4ucGFuZWxEYXRhLmNvbnN0cmFpbnRzLFxuICAgIHBhbmVsU2l6ZSxcbiAgICBwaXZvdEluZGljZXNcbiAgfTtcbn1cblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy93aW5kb3dzcGxpdHRlci9cblxuZnVuY3Rpb24gdXNlV2luZG93U3BsaXR0ZXJSZXNpemVIYW5kbGVyQmVoYXZpb3Ioe1xuICBkaXNhYmxlZCxcbiAgaGFuZGxlSWQsXG4gIHJlc2l6ZUhhbmRsZXIsXG4gIHBhbmVsR3JvdXBFbGVtZW50XG59KSB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8IHJlc2l6ZUhhbmRsZXIgPT0gbnVsbCB8fCBwYW5lbEdyb3VwRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZUVsZW1lbnQgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50KGhhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgaWYgKGhhbmRsZUVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbktleURvd24gPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXNpemVIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkY2XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwSWQgPSBoYW5kbGVFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIik7XG4gICAgICAgICAgICBhc3NlcnQoZ3JvdXBJZCk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cChncm91cElkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRJbmRleChncm91cElkLCBoYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0KGluZGV4ICE9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGV2ZW50LnNoaWZ0S2V5ID8gaW5kZXggPiAwID8gaW5kZXggLSAxIDogaGFuZGxlcy5sZW5ndGggLSAxIDogaW5kZXggKyAxIDwgaGFuZGxlcy5sZW5ndGggPyBpbmRleCArIDEgOiAwO1xuICAgICAgICAgICAgY29uc3QgbmV4dEhhbmRsZSA9IGhhbmRsZXNbbmV4dEluZGV4XTtcbiAgICAgICAgICAgIG5leHRIYW5kbGUuZm9jdXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGFuZGxlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgIH07XG4gIH0sIFtwYW5lbEdyb3VwRWxlbWVudCwgZGlzYWJsZWQsIGhhbmRsZUlkLCByZXNpemVIYW5kbGVyXSk7XG59XG5cbmZ1bmN0aW9uIFBhbmVsUmVzaXplSGFuZGxlKHtcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyA9IFwiXCIsXG4gIGRpc2FibGVkID0gZmFsc2UsXG4gIGlkOiBpZEZyb21Qcm9wcyxcbiAgb25EcmFnZ2luZyxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzID0ge30sXG4gIHRhYkluZGV4ID0gMCxcbiAgdGFnTmFtZTogVHlwZSA9IFwiZGl2XCIsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgZWxlbWVudFJlZiA9IHVzZVJlZihudWxsKTtcblxuICAvLyBVc2UgYSByZWYgdG8gZ3VhcmQgYWdhaW5zdCB1c2VycyBwYXNzaW5nIGlubGluZSBwcm9wc1xuICBjb25zdCBjYWxsYmFja3NSZWYgPSB1c2VSZWYoe1xuICAgIG9uRHJhZ2dpbmdcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQub25EcmFnZ2luZyA9IG9uRHJhZ2dpbmc7XG4gIH0pO1xuICBjb25zdCBwYW5lbEdyb3VwQ29udGV4dCA9IHVzZUNvbnRleHQoUGFuZWxHcm91cENvbnRleHQpO1xuICBpZiAocGFuZWxHcm91cENvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFuZWxSZXNpemVIYW5kbGUgY29tcG9uZW50cyBtdXN0IGJlIHJlbmRlcmVkIHdpdGhpbiBhIFBhbmVsR3JvdXAgY29udGFpbmVyYCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGRpcmVjdGlvbixcbiAgICBkcmFnU3RhdGUsXG4gICAgZ3JvdXBJZCxcbiAgICByZWdpc3RlclJlc2l6ZUhhbmRsZSxcbiAgICBzdGFydERyYWdnaW5nLFxuICAgIHN0b3BEcmFnZ2luZyxcbiAgICBwYW5lbEdyb3VwRWxlbWVudFxuICB9ID0gcGFuZWxHcm91cENvbnRleHQ7XG4gIGNvbnN0IHJlc2l6ZUhhbmRsZUlkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBpc0RyYWdnaW5nID0gKGRyYWdTdGF0ZSA9PT0gbnVsbCB8fCBkcmFnU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYWdTdGF0ZS5kcmFnSGFuZGxlSWQpID09PSByZXNpemVIYW5kbGVJZDtcbiAgY29uc3QgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Jlc2l6ZUhhbmRsZXIsIHNldFJlc2l6ZUhhbmRsZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHN0b3BEcmFnZ2luZ0FuZEJsdXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gQ2xpY2tpbmcgb24gdGhlIGRyYWcgaGFuZGxlIHNob3VsZG4ndCBsZWF2ZSBpdCBmb2N1c2VkO1xuICAgIC8vIFRoYXQgd291bGQgY2F1c2UgdGhlIFBhbmVsR3JvdXAgdG8gdGhpbmsgaXQgd2FzIHN0aWxsIGFjdGl2ZS5cbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGFzc2VydChlbGVtZW50KTtcbiAgICBlbGVtZW50LmJsdXIoKTtcbiAgICBzdG9wRHJhZ2dpbmcoKTtcbiAgICBjb25zdCB7XG4gICAgICBvbkRyYWdnaW5nXG4gICAgfSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgIGlmIChvbkRyYWdnaW5nKSB7XG4gICAgICBvbkRyYWdnaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtzdG9wRHJhZ2dpbmddKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHNldFJlc2l6ZUhhbmRsZXIobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXIgPSByZWdpc3RlclJlc2l6ZUhhbmRsZShyZXNpemVIYW5kbGVJZCk7XG4gICAgICBzZXRSZXNpemVIYW5kbGVyKCgpID0+IHJlc2l6ZUhhbmRsZXIpO1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCByZXNpemVIYW5kbGVJZCwgcmVnaXN0ZXJSZXNpemVIYW5kbGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgcmVzaXplSGFuZGxlciA9PSBudWxsIHx8ICFpc0RyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uTW92ZSA9IGV2ZW50ID0+IHtcbiAgICAgIHJlc2l6ZUhhbmRsZXIoZXZlbnQpO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlID0gZXZlbnQgPT4ge1xuICAgICAgcmVzaXplSGFuZGxlcihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGFzc2VydChlbGVtZW50KTtcbiAgICBjb25zdCB0YXJnZXREb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBzdG9wRHJhZ2dpbmdBbmRCbHVyKTtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIG9uTW91c2VMZWF2ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHN0b3BEcmFnZ2luZ0FuZEJsdXIpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgc3RvcERyYWdnaW5nQW5kQmx1cik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRhcmdldERvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIHN0b3BEcmFnZ2luZ0FuZEJsdXIpO1xuICAgICAgdGFyZ2V0RG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW92ZSk7XG4gICAgICB0YXJnZXREb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcbiAgICAgIHRhcmdldERvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgb25Nb3VzZUxlYXZlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBzdG9wRHJhZ2dpbmdBbmRCbHVyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgc3RvcERyYWdnaW5nQW5kQmx1cik7XG4gICAgfTtcbiAgfSwgW2RpcmVjdGlvbiwgZGlzYWJsZWQsIGlzRHJhZ2dpbmcsIHJlc2l6ZUhhbmRsZXIsIHN0b3BEcmFnZ2luZ0FuZEJsdXJdKTtcbiAgdXNlV2luZG93U3BsaXR0ZXJSZXNpemVIYW5kbGVyQmVoYXZpb3Ioe1xuICAgIGRpc2FibGVkLFxuICAgIGhhbmRsZUlkOiByZXNpemVIYW5kbGVJZCxcbiAgICByZXNpemVIYW5kbGVyLFxuICAgIHBhbmVsR3JvdXBFbGVtZW50XG4gIH0pO1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBjdXJzb3I6IGdldEN1cnNvclN0eWxlKGRpcmVjdGlvbiksXG4gICAgdG91Y2hBY3Rpb246IFwibm9uZVwiLFxuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gIH07XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFR5cGUsIHtcbiAgICAuLi5yZXN0LFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzLFxuICAgIG9uQmx1cjogKCkgPT4gc2V0SXNGb2N1c2VkKGZhbHNlKSxcbiAgICBvbkZvY3VzOiAoKSA9PiBzZXRJc0ZvY3VzZWQodHJ1ZSksXG4gICAgb25Nb3VzZURvd246IGV2ZW50ID0+IHtcbiAgICAgIHN0YXJ0RHJhZ2dpbmcocmVzaXplSGFuZGxlSWQsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgICAgYXNzZXJ0KGNhbGxiYWNrcyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uRHJhZ2dpbmdcbiAgICAgIH0gPSBjYWxsYmFja3M7XG4gICAgICBpZiAob25EcmFnZ2luZykge1xuICAgICAgICBvbkRyYWdnaW5nKHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25Nb3VzZVVwOiBzdG9wRHJhZ2dpbmdBbmRCbHVyLFxuICAgIG9uVG91Y2hDYW5jZWw6IHN0b3BEcmFnZ2luZ0FuZEJsdXIsXG4gICAgb25Ub3VjaEVuZDogc3RvcERyYWdnaW5nQW5kQmx1cixcbiAgICBvblRvdWNoU3RhcnQ6IGV2ZW50ID0+IHtcbiAgICAgIHN0YXJ0RHJhZ2dpbmcocmVzaXplSGFuZGxlSWQsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgICAgYXNzZXJ0KGNhbGxiYWNrcyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uRHJhZ2dpbmdcbiAgICAgIH0gPSBjYWxsYmFja3M7XG4gICAgICBpZiAob25EcmFnZ2luZykge1xuICAgICAgICBvbkRyYWdnaW5nKHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVmOiBlbGVtZW50UmVmLFxuICAgIHJvbGU6IFwic2VwYXJhdG9yXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIHRhYkluZGV4LFxuICAgIC8vIENTUyBzZWxlY3RvcnNcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtZGlyZWN0aW9uXCI6IGRpcmVjdGlvbixcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIjogZ3JvdXBJZCxcbiAgICBcImRhdGEtcmVzaXplLWhhbmRsZVwiOiBcIlwiLFxuICAgIFwiZGF0YS1yZXNpemUtaGFuZGxlLWFjdGl2ZVwiOiBpc0RyYWdnaW5nID8gXCJwb2ludGVyXCIgOiBpc0ZvY3VzZWQgPyBcImtleWJvYXJkXCIgOiB1bmRlZmluZWQsXG4gICAgXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtZW5hYmxlZFwiOiAhZGlzYWJsZWQsXG4gICAgXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRcIjogcmVzaXplSGFuZGxlSWRcbiAgfSk7XG59XG5QYW5lbFJlc2l6ZUhhbmRsZS5kaXNwbGF5TmFtZSA9IFwiUGFuZWxSZXNpemVIYW5kbGVcIjtcblxuZnVuY3Rpb24gZ2V0UGFuZWxFbGVtZW50KGlkLCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBzY29wZS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYW5lbC1pZD1cIiR7aWR9XCJdYCk7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFBhbmVsRWxlbWVudHNGb3JHcm91cChncm91cElkLCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXBhbmVsXVtkYXRhLXBhbmVsLWdyb3VwLWlkPVwiJHtncm91cElkfVwiXWApKTtcbn1cblxuZXhwb3J0IHsgUGFuZWwsIFBhbmVsR3JvdXAsIFBhbmVsUmVzaXplSGFuZGxlLCBhc3NlcnQsIGdldFBhbmVsRWxlbWVudCwgZ2V0UGFuZWxFbGVtZW50c0Zvckdyb3VwLCBnZXRQYW5lbEdyb3VwRWxlbWVudCwgZ2V0UmVzaXplSGFuZGxlRWxlbWVudCwgZ2V0UmVzaXplSGFuZGxlRWxlbWVudEluZGV4LCBnZXRSZXNpemVIYW5kbGVFbGVtZW50c0Zvckdyb3VwLCBnZXRSZXNpemVIYW5kbGVQYW5lbElkcyB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUNvbnRleHQiLCJjcmVhdGVSZWYiLCJmb3J3YXJkUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUxheW91dEVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUlkIiwidG9TdHJpbmciLCJQYW5lbEdyb3VwQ29udGV4dCIsImRpc3BsYXlOYW1lIiwid3JhcHBlZFVzZUlkIiwiY291bnRlciIsInVzZVVuaXF1ZUlkIiwiaWRGcm9tUGFyYW1zIiwiaWRGcm9tVXNlSWQiLCJpZFJlZiIsImN1cnJlbnQiLCJQYW5lbFdpdGhGb3J3YXJkZWRSZWYiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImNsYXNzTmFtZUZyb21Qcm9wcyIsImNvbGxhcHNlZFNpemUiLCJjb2xsYXBzaWJsZSIsImRlZmF1bHRTaXplIiwiZm9yd2FyZGVkUmVmIiwiaWQiLCJpZEZyb21Qcm9wcyIsIm1heFNpemUiLCJtaW5TaXplIiwib25Db2xsYXBzZSIsIm9uRXhwYW5kIiwib25SZXNpemUiLCJvcmRlciIsInN0eWxlIiwic3R5bGVGcm9tUHJvcHMiLCJ0YWdOYW1lIiwiVHlwZSIsInJlc3QiLCJjb250ZXh0IiwiRXJyb3IiLCJjb2xsYXBzZVBhbmVsIiwiZXhwYW5kUGFuZWwiLCJnZXRQYW5lbFNpemUiLCJnZXRQYW5lbFN0eWxlIiwiZ3JvdXBJZCIsImlzUGFuZWxDb2xsYXBzZWQiLCJyZWV2YWx1YXRlUGFuZWxDb25zdHJhaW50cyIsInJlZ2lzdGVyUGFuZWwiLCJyZXNpemVQYW5lbCIsInVucmVnaXN0ZXJQYW5lbCIsInBhbmVsSWQiLCJwYW5lbERhdGFSZWYiLCJjYWxsYmFja3MiLCJjb25zdHJhaW50cyIsImlkSXNGcm9tUHJvcHMiLCJ1bmRlZmluZWQiLCJkZXZXYXJuaW5nc1JlZiIsImRpZExvZ01pc3NpbmdEZWZhdWx0U2l6ZVdhcm5pbmciLCJjb25zb2xlIiwid2FybiIsImNvbGxhcHNlIiwiZXhwYW5kIiwiZ2V0SWQiLCJnZXRTaXplIiwiaXNDb2xsYXBzZWQiLCJpc0V4cGFuZGVkIiwicmVzaXplIiwic2l6ZSIsInBhcnNlRmxvYXQiLCJmbGV4R3JvdyIsInRvRml4ZWQiLCJQYW5lbCIsInByb3BzIiwicmVmIiwiYXNzZXJ0IiwiZXhwZWN0ZWRDb25kaXRpb24iLCJtZXNzYWdlIiwiZXJyb3IiLCJQUkVDSVNJT04iLCJmdXp6eUNvbXBhcmVOdW1iZXJzIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJmcmFjdGlvbkRpZ2l0cyIsImRlbHRhIiwiZnV6enlOdW1iZXJzRXF1YWwiLCJwYW5lbENvbnN0cmFpbnRzIiwicGFuZWxDb25zdHJhaW50c0FycmF5IiwicGFuZWxJbmRleCIsImhhbGZ3YXlQb2ludCIsIk1hdGgiLCJtaW4iLCJhZGp1c3RMYXlvdXRCeURlbHRhIiwibGF5b3V0IiwicHJldkxheW91dCIsInBpdm90SW5kaWNlcyIsInRyaWdnZXIiLCJuZXh0TGF5b3V0IiwiZmlyc3RQaXZvdEluZGV4Iiwic2Vjb25kUGl2b3RJbmRleCIsImRlbHRhQXBwbGllZCIsImluZGV4IiwicHJldlNpemUiLCJsb2NhbERlbHRhIiwiYWJzIiwiaW5jcmVtZW50IiwibWF4QXZhaWxhYmxlRGVsdGEiLCJtYXhTYWZlU2l6ZSIsImxlbmd0aCIsIm1pbkFic0RlbHRhIiwicGl2b3RJbmRleCIsImRlbHRhUmVtYWluaW5nIiwidW5zYWZlU2l6ZSIsInNhZmVTaXplIiwidG9QcmVjaXNpb24iLCJsb2NhbGVDb21wYXJlIiwibnVtZXJpYyIsInRvdGFsU2l6ZSIsInJlZHVjZSIsInRvdGFsIiwiZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cCIsInNjb3BlIiwiZG9jdW1lbnQiLCJBcnJheSIsImZyb20iLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0UmVzaXplSGFuZGxlRWxlbWVudEluZGV4IiwiaGFuZGxlcyIsImZpbmRJbmRleCIsImhhbmRsZSIsImdldEF0dHJpYnV0ZSIsImRldGVybWluZVBpdm90SW5kaWNlcyIsImRyYWdIYW5kbGVJZCIsInBhbmVsR3JvdXBFbGVtZW50IiwiZ2V0UGFuZWxHcm91cEVsZW1lbnQiLCJyb290RWxlbWVudCIsIl9kYXRhc2V0IiwiSFRNTEVsZW1lbnQiLCJkYXRhc2V0IiwicGFuZWxHcm91cElkIiwiZWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRSZXNpemVIYW5kbGVFbGVtZW50IiwiZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMiLCJoYW5kbGVJZCIsInBhbmVsc0FycmF5IiwiX3BhbmVsc0FycmF5JGluZGV4JGlkIiwiX3BhbmVsc0FycmF5JGluZGV4IiwiX3BhbmVsc0FycmF5JGlkIiwiX3BhbmVsc0FycmF5IiwiaW5kZXhPZiIsImlkQmVmb3JlIiwiaWRBZnRlciIsInVzZVdpbmRvd1NwbGl0dGVyUGFuZWxHcm91cEJlaGF2aW9yIiwiY29tbWl0dGVkVmFsdWVzUmVmIiwiZWFnZXJWYWx1ZXNSZWYiLCJwYW5lbERhdGFBcnJheSIsInNldExheW91dCIsImRpZFdhcm5BYm91dE1pc3NpbmdSZXNpemVIYW5kbGUiLCJlYWdlclZhbHVlcyIsImdyb3VwRWxlbWVudCIsImNsZWFudXBGdW5jdGlvbnMiLCJtYXAiLCJvbktleURvd24iLCJldmVudCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJrZXkiLCJwcmV2ZW50RGVmYXVsdCIsInBhbmVsRGF0YSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZm9yRWFjaCIsImNsZWFudXBGdW5jdGlvbiIsImFyZUVxdWFsIiwiYXJyYXlBIiwiYXJyYXlCIiwiaXNLZXlEb3duIiwidHlwZSIsImlzTW91c2VFdmVudCIsInN0YXJ0c1dpdGgiLCJpc1RvdWNoRXZlbnQiLCJnZXRSZXNpemVFdmVudEN1cnNvclBvc2l0aW9uIiwiZGlyZWN0aW9uIiwiaXNIb3Jpem9udGFsIiwiY2xpZW50WCIsImNsaWVudFkiLCJmaXJzdFRvdWNoIiwidG91Y2hlcyIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2FsY3VsYXRlRHJhZ09mZnNldFBlcmNlbnRhZ2UiLCJpbml0aWFsRHJhZ1N0YXRlIiwiaGFuZGxlRWxlbWVudCIsImluaXRpYWxDdXJzb3JQb3NpdGlvbiIsImN1cnNvclBvc2l0aW9uIiwiZ3JvdXBSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZ3JvdXBTaXplSW5QaXhlbHMiLCJ3aWR0aCIsImhlaWdodCIsIm9mZnNldFBpeGVscyIsIm9mZnNldFBlcmNlbnRhZ2UiLCJjYWxjdWxhdGVEZWx0YVBlcmNlbnRhZ2UiLCJrZXlib2FyZFJlc2l6ZUJ5Iiwic2hpZnRLZXkiLCJtb3ZlbWVudCIsImNhbGxQYW5lbENhbGxiYWNrcyIsInBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXAiLCJsYXN0Tm90aWZpZWRTaXplIiwiY29tcGFyZUxheW91dHMiLCJhIiwiYiIsImNvbXB1dGVQYW5lbEZsZXhCb3hTdHlsZSIsImRyYWdTdGF0ZSIsInByZWNpc2lvbiIsImZsZXhCYXNpcyIsImZsZXhTaHJpbmsiLCJvdmVyZmxvdyIsInBvaW50ZXJFdmVudHMiLCJjdXJyZW50U3RhdGUiLCJnZXRDdXJzb3JTdHlsZSIsInN0YXRlIiwicmVzZXRHbG9iYWxDdXJzb3JTdHlsZSIsImhlYWQiLCJyZW1vdmVDaGlsZCIsInNldEdsb2JhbEN1cnNvclN0eWxlIiwiYXBwZW5kQ2hpbGQiLCJpbm5lckhUTUwiLCJkZWJvdW5jZSIsImNhbGxiYWNrIiwiZHVyYXRpb25NcyIsInRpbWVvdXRJZCIsImNhbGxhYmxlIiwiYXJncyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2UiLCJzdG9yYWdlT2JqZWN0IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIm5hbWUiLCJzZXRJdGVtIiwidmFsdWUiLCJnZXRQYW5lbEdyb3VwS2V5IiwiYXV0b1NhdmVJZCIsImdldFBhbmVsS2V5IiwicGFuZWxzIiwicGFuZWwiLCJKU09OIiwic3RyaW5naWZ5Iiwic29ydCIsImpvaW4iLCJsb2FkU2VyaWFsaXplZFBhbmVsR3JvdXBTdGF0ZSIsInN0b3JhZ2UiLCJwYW5lbEdyb3VwS2V5Iiwic2VyaWFsaXplZCIsInBhcnNlZCIsInBhcnNlIiwic2F2ZVBhbmVsR3JvdXBTdGF0ZSIsInBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZSIsInNpemVzIiwiX2xvYWRTZXJpYWxpemVkUGFuZWxHMiIsInBhbmVsS2V5IiwiZXhwYW5kVG9TaXplcyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsInZhbGlkYXRlUGFuZWxDb25zdHJhaW50cyIsIndhcm5pbmdzIiwicHVzaCIsInZhbGlkYXRlUGFuZWxHcm91cExheW91dCIsIm5leHRMYXlvdXRUb3RhbFNpemUiLCJhY2N1bXVsYXRlZCIsInJlbWFpbmluZ1NpemUiLCJMT0NBTF9TVE9SQUdFX0RFQk9VTkNFX0lOVEVSVkFMIiwiZGVmYXVsdFN0b3JhZ2UiLCJkZWJvdW5jZU1hcCIsIlBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmIiwib25MYXlvdXQiLCJwYW5lbEdyb3VwRWxlbWVudFJlZiIsInNldERyYWdTdGF0ZSIsInBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYiLCJwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZiIsIk1hcCIsInByZXZEZWx0YVJlZiIsInBhbmVsRGF0YUFycmF5Q2hhbmdlZCIsImRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nIiwiZGlkTG9nUGFuZWxDb25zdHJhaW50c1dhcm5pbmciLCJwcmV2UGFuZWxJZHMiLCJnZXRMYXlvdXQiLCJ1bnNhZmVMYXlvdXQiLCJzYWZlTGF5b3V0IiwiZGVib3VuY2VkU2F2ZSIsImNsb25lZFBhbmVsRGF0YUFycmF5IiwiY2xvbmVkUGFuZWxTaXplc0JlZm9yZUNvbGxhcHNlIiwicGFuZWxJZHMiLCJwYW5lbHNIYXZlQ2hhbmdlZCIsImZpbmQiLCJpc1ZhbGlkIiwicGFuZWxTaXplIiwicGFuZWxEYXRhSGVscGVyIiwic2V0IiwiaXNMYXN0UGFuZWwiLCJmaW5kUGFuZWxEYXRhSW5kZXgiLCJwcmV2UGFuZWxTaXplIiwiZ2V0IiwiYmFzZVNpemUiLCJpc1BhbmVsRXhwYW5kZWQiLCJwYW5lbEEiLCJwYW5lbEIiLCJvcmRlckEiLCJvcmRlckIiLCJyZWdpc3RlclJlc2l6ZUhhbmRsZSIsInJlc2l6ZUhhbmRsZXIiLCJpbml0aWFsTGF5b3V0IiwiZGlyIiwibGF5b3V0Q2hhbmdlZCIsInVuc2FmZVBhbmVsU2l6ZSIsInByZXZDb25zdHJhaW50cyIsInByZXZDb2xsYXBzZWRTaXplIiwicHJldkNvbGxhcHNpYmxlIiwicHJldkRlZmF1bHRTaXplIiwicHJldk1heFNpemUiLCJwcmV2TWluU2l6ZSIsIm5leHRDb2xsYXBzZWRTaXplIiwibmV4dENvbGxhcHNpYmxlIiwibmV4dERlZmF1bHRTaXplIiwibmV4dE1heFNpemUiLCJuZXh0TWluU2l6ZSIsInN0YXJ0RHJhZ2dpbmciLCJkcmFnSGFuZGxlUmVjdCIsInN0b3BEcmFnZ2luZyIsInNwbGljZSIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiUHJvdmlkZXIiLCJQYW5lbEdyb3VwIiwicHJldlBhbmVsRGF0YSIsInVzZVdpbmRvd1NwbGl0dGVyUmVzaXplSGFuZGxlckJlaGF2aW9yIiwiZGlzYWJsZWQiLCJuZXh0SW5kZXgiLCJuZXh0SGFuZGxlIiwiZm9jdXMiLCJQYW5lbFJlc2l6ZUhhbmRsZSIsIm9uRHJhZ2dpbmciLCJ0YWJJbmRleCIsImVsZW1lbnRSZWYiLCJjYWxsYmFja3NSZWYiLCJwYW5lbEdyb3VwQ29udGV4dCIsInJlc2l6ZUhhbmRsZUlkIiwiaXNEcmFnZ2luZyIsImlzRm9jdXNlZCIsInNldElzRm9jdXNlZCIsInNldFJlc2l6ZUhhbmRsZXIiLCJzdG9wRHJhZ2dpbmdBbmRCbHVyIiwiYmx1ciIsIm9uTW92ZSIsIm9uTW91c2VMZWF2ZSIsInRhcmdldERvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImJvZHkiLCJ3aW5kb3ciLCJjdXJzb3IiLCJ0b3VjaEFjdGlvbiIsInVzZXJTZWxlY3QiLCJvbkJsdXIiLCJvbkZvY3VzIiwib25Nb3VzZURvd24iLCJuYXRpdmVFdmVudCIsIm9uTW91c2VVcCIsIm9uVG91Y2hDYW5jZWwiLCJvblRvdWNoRW5kIiwib25Ub3VjaFN0YXJ0Iiwicm9sZSIsImdldFBhbmVsRWxlbWVudCIsImdldFBhbmVsRWxlbWVudHNGb3JHcm91cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js\n");

/***/ })

};
;